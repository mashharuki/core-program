# メモ

## 2023年分の回答

### Week1

#### 概念の基礎

- ゼロ知識証明とは何か

  「正しい答えを知っている」ことだけを証明して、答えそのものは見せない高度な暗号技術。プライバシー保護や計算効率化などに役立つ

- 健全性、完全性、ゼロ知識性とは何か
  - 健全性
    - 嘘は、絶対に証明できない（見破られる）こと。
    - 嘘つきがシステムを悪用するのを防ぐ
  - 完全性
    - 正しいことは、必ず証明できること
    - 正直者が報われるようにする
  - ゼロ知識性
    - 証明されても、秘密の内容は相手に知られないこと
    - プライバシーを守ること

- 対話型と非対話型の証明の違いは何ですか？
  - 対話型
    - 証明したい人と検証者が何度もやり取りして証明が完了するタイプ
    - メリット
      - やり取りしながら調整でき、相手の質問に合わせて証明を柔軟に見せられる。
      - 途中で相手が納得しなければ追加の質問に答えて信頼を高められる。
    - デメリット
      - 何度も会話する必要があり、時間や通信がかかる。
      - 証明を保存して後で別の人に見せることが難しい。

  - 非対話型
    - 証明者から検証者に対して、たった一度だけメッセージ（証明、またはProof）を送れば、証明が完了するタイプ
    - メリット
      - 証明が1回のメッセージで済むので、送っておけばいつでも誰でも確認できる。
      - ブロックチェーンのように多くの人が同じ証明をチェックしたい場面で便利。
    - デメリット
      - 一度作った証明が間違っていたらやり直すのが大変。
      - 成り立たせるために特別な仕組み（例：共通の「ランダムな設定」やハッシュ関数の利用）が必要で、条件が多くなる。

- ウォーリーを探せはわかりやすい
  - どこにウォーリーがいるかは伝えたくない。でも見つけたことがだけを共有したい。
  - この応用としてパスワードとかをサーバー側に直接伝えることなく、認証サービスを作るときなどに役立ちそう(まさにこれってSuiのzkLogin)

- もっとも興味深い応用例
  - ZK Rollup
    - プライバシー保護のために生まれたアイディアを計算効率化に応用しているのがまず面白い。
    - ZKの本質的な部分は **プライバシーの保護と計算効率化(スケーラビリティの向上)** に使える技術だということが理解できた。

- 他の応用例
  - 将来的に人の意識を交換するような技術が実現すると考えられている。重要なプライバシーデータを秘匿化しつつ、純粋に記憶力や論理的思考力のみをレンタルできるようにしても良いかもしれない。

#### 数学の基礎知識

- 基礎：
  - 素数・合成数

    素数と合成数は、1より大きい自然数を、その約数（割り切れる数）の数によって分類したもの。

    - 素数 
      - 1と自分自身でしか割り切れない自然数。
      - 例：2, 3, 5, 7, 11…。
    - 合成数 
      - 1と自分以外にも割れる相手がいる自然数。
      - 例： 4（2×2）、6（2×3）、9（3×3）など。

  - 最大公約数（GCD）

    2つ以上の整数に共通する約数（割り切れる数）の中で、最も大きい数のこと

- モジュラー算術と合同：
  - モジュラー算術とは？
    - 割り算の余りに注目した特殊な計算方法のこと。
    - 「○で割った余りだけを考える計算」。12で割った余りを考えるなら、14も26も38も全部「2時」と同じです。これがモジュラー算術の基本的な考え方。
    - 「ぐるぐる時計算」と考えるとわかりやすいです。たとえば12時間の時計では、10時に4時間進むと14時ではなく2時になりますよね。この「12で一周して同じ位置に戻
  る」ルールを使う計算がモジュラー算術です。

  - 合同類の考え方
    - モジュラー算術において、同じ数を法として割ったときに同じ余りになる整数のグループのこと。
    - 12時間の時計で考えると、2時・14時・26時は全部「2時と同じ場所」なので同じ箱に入ります。この「同じあまりの数字を集めた箱」が合同類です。
    - 例：法5の合同類
      - 余りが0になる数の合同類
      - このグループには、5で割り切れるすべての整数が含まれます。
      - ..., -10, -5, 0, 5, 10, 15, ...

- 群論：
  - 群構造:
    - ある集合に演算が定義され、いくつかの満たすべき公理（ルール）が定められているときの、その集合と演算が持つ「性質」や「骨組み」のこと
    - 群構造を持つことで、その集合の中の要素を「足したり」「かけたり」するような操作ができるようになり、その操作には特定の決まりがある、ということ
    - 群構造の3つの公理
      - 結合法則
        - 3つ以上の要素を演算する場合、どの2つを先に演算しても結果は同じになります。
        - 例：\((A\cdot B)\cdot C=A\cdot (B\cdot C)\)
      - 単位元の存在
        - ある特定の要素（単位元）をどの要素に演算しても、その要素自体は変化しません。
        - 例：\(A\cdot E=E\cdot A=A\)（\(E\)が単位元）
      - 逆元の存在
        - どの要素にも、演算すると単位元になるような要素（逆元）が必ず存在します。
        - 例：\(A\cdot A^{-1}=A^{-1}\cdot A=E\)（\(A^{-1}\)が\(A\)の逆元）
    - 例：
      - 「整数の足し算」
      - この場合の集合は整数、演算にあたるのは足し算
    - 群構造は、数学のさまざまな分野で現れる基本的な骨組みです。この構造を理解することで、一見異なる分野（例えば、幾何学と物理学）に共通する性質や法則を見つけることができます。
    
  - 群演算:
    - ある特別なルールを持った、集合の中の2つの要素を組み合わせて新しい要素を生み出す操作のこと
    - 「群構造」を成立させるために必要な「演算」が、この「群演算」にあたる
    - 最も身近な例は、整数の足し算です。この場合の「群演算」は足し算です。

- さらに深く：
  - 有限群： 
    - 要素の数が有限である群のこと。
    - 例：正方形の対称性の群
      - 集合: 正方形を動かす8つの操作（回転と反転）の集まり。
        - 0度、90度、180度、270度の回転
        - 垂直、水平、2本の対角線に沿った反転
      - 演算: 操作を連続して行うこと。
        - たとえば、「90度回転」のあとに「水平反転」を行う、といった操作です。
      - ルール: これらの操作はすべて群演算の4つのルールを満たします。
      - 閉鎖性: どの操作を組み合わせても、結果は8つのうちのどれかの操作になります。
      - 単位元: 「0度回転（何もしない）」という操作が単位元になります。
  - 巡回群：
      - たった1つの要素を繰り返し演算するだけで、すべての要素を作り出すことができる群のこと
  - 生成元：
      - 生成元とは、特定の代数構造（群など）において、繰り返し演算を行うことで、その構造全体のすべての要素を作り出すことができる特別な要素のこと
      - 生成元は、その構造を「生み出す種」のようなもの
      - 例：時計の文字盤

        この例では、「1時間進める」という操作（生成元）を繰り返すことで、時計のすべての数字（要素）を作り出すことができます。
        - 集合: \(\{12,1,2,...,11\}\) の12個の数字
        - 演算: 1時間を進める操作
        - 生成元: 「1時間」という操作
          - 「1時間」を1回 → 1時
          - 「1時間」を2回 → 2時
  - 有限体：
      - 有限体とは、要素の数が有限でありながら、四則演算（足し算、引き算、掛け算、割り算）が自由にできる集合のこと。有限体はガロア体（Galois Field）とも呼ばれ、GFと記載されることが多い。有限体は、要素の数が有限であるため、コンピューターで扱うのに非常に適している。そのため、暗号技術や通信エラー訂正など、情報科学の分野で広く応用されています。
        - 四則演算ができる: 集合の任意の2つの要素を足したり引いたりかけたり割ったりしても、その結果が必ず元の集合の中に戻るという性質（閉鎖性）を持ちます。
        - 割り算のルール: ただし、0で割ることはできません。
        - 例
          - 3を法とする有限体（GF(3)）
          - 集合: \(\{0,1,2\}\)
          - 足し算（mod 3）: 
            - \(1+2=3\) なので、余りは \(0\)
          - 掛け算（mod 3）:
            - \(1\times 2=2\)
            - \(2\times 2=4\) なので、余りは \(1\)
          - 割り算（mod 3）:
            - \(1\div 2\) は、**\(2\times x=1\)（mod 3）**となる \(x\) を探します。上記の掛け算から、\(x=2\) です。

#### 演習

#### 理解度チェック

1. 帽子の三色塗り分け問題（グラフ三色問題）

    - 複数の人が輪になって座り、互いの帽子は見えますが、自分の帽子の色は見えないという状況で、自分の帽子の色を推測するというもの
    - 絵で描くと、人を丸で、隣同士を線で結んだ図（グラフ）になるから「グラフ三色問題」と呼ぶんだ。
    - みんなで話し合って順番に色を決めたり、３色が足りないと気付いたら最初からやり直したりして、ルールを守る塗り方を探す遊びなんだよ。

2. アリババの洞窟のたとえ話

  - 2つの通路と魔法の扉。秘密の合言葉を知る証明者(ペギー)は、検証者(ビクター)が指示した側の通路から出てくることで「言葉を知っている」ことを示すが、言葉自体は明かさない。繰り返しで信頼度を高める対話型の証明。

3. 対話型と非対話型の証明の違い
  - 対話型は証明者と検証者が何度もやりとりして証明が正しいことを検証する方法。
  - 非対話型は証明者と検証者が1回のやりとりで証明が正しいことを検証する方法。

#### モジュラー演算

- 1. 7 mod 13. 
  A: 7
  
- 2. 15 mod 13. 
  A:2

- 3. (7 + 15) mod 13. 
  A: 9

- 4. (7 mod 13 + 15 mod 13) mod 13. 
  A: 9

#### 生成元

巡回群 (Z_{12}, + mod 12)（12を法とする加法群）について：

- 1. 生成元とは何ですか？

  A: 特定の代数構造（群など）において、繰り返し演算を行うことで、その構造全体のすべての要素を作り出すことができる特別な要素のこと

- 2. この群の生成元を一つ挙げてください。

  A: 1 (1を足し引きすることで0~11を全て生成できるから)

- 3. 他にも生成元はありますか？あれば挙げてください。  

  A: 5,7,11(それぞれ使って足し引きすることで0〜11の全ての要素を生成できる。)

#### 加算・減算・乗算をサポートする簡単なモジュラー計算機を作成する

関数 `modularCalculator` は次の4引数を取ります：
- 文字列 `op`（演算子: '+', '-', '*' のいずれか）
- 整数 `num1`, `num2`（オペランド）
- 整数 `mod`（法）

計算結果に対して mod を取った値を返してください。  
減算で負になることがある点に注意し、必要に応じて `mod` を足して正にしてください。

結果

```js
function modularCalculator(op, num1, num2, mod) {
    let result = 0;
    switch (op) {
        case '+':
          // 足し算して法で割る
          result = (num1 + num2) % mod;
          break;
        case '-':
          // 引き算して法で割る
          result = (num1 - num2) % mod;
          // 正の数に補正sルウ
          if (result < 0) result += mod;
          break;
        case '*':
          // 掛け算して法で割る
          result = (num1 * num2) % mod;
          break;
        default:
          return "Invalid operation";
    }
    return result;
}

modularCalculator('+', 10, 15, 12); // 1
modularCalculator('-', 10, 15, 12); // 7
modularCalculator('*', 10, 15, 12); // 6
```

### Week2

- 対称鍵と非対称鍵の主な違いは？

  鍵の数が1本か2本か

- AES の動作概要

  - AES（Advanced Encryption Standard）はNISTが2001年に採用した共通鍵ブロック暗号で、128ビットのブロックを扱い鍵長は128/192/256ビットに対応します。
  - 内部では128ビットのデータを8ビット×16個の4×4行列（Stateと呼ぶ）に並べ替え、各ラウンドで代入・並べ替え・行列演算・鍵加算を繰り返すことで拡散と混同を実現します。
  - まずState表現に慣れましょう。平文128ビットを列優先で4列×4行に詰めると、各操作が視覚化しやすくなります。
  - 主要ステップを順に把握します：SubBytesは非線形S-box代入で混同を導入、ShiftRowsは行ごとに循環シフトして列間の依存を広げ、MixColumnsはGF(2⁸)多項式演算で列内のビットを混ぜ、AddRoundKeyはラウンド鍵とのXORで鍵依存性を注入します。最後のラウンドのみMixColumnsを省略します。
  - 鍵スケジュールは初期鍵をワード（32ビット）単位で展開し、RotWord・SubWord・ラウンド定数（Rcon）を使って各ラウンド鍵を生成する仕組みです。鍵長ごとに展開ルールが少しずつ変わるので、図を描きながら追うと理解が進みます。
  - AES自体はブロック暗号なので、実際の通信ではCBCやGCMなどの運用モードで連結します。この段階では「AES本体は固定長ブロック＋鍵で決まる置換」「モードがブロックの連携方法を定義する」と切り分けて覚えると混乱しません。
  - 4×4行列に平文を詰め、1回分のSubBytesとShiftRowsを手計算してStateの変化を確認する。
  - 小さなスクリプト（例：Node.jsのcryptoではなく自作）でS-box代入とMixColumnsの実装を行い、公式テストベクトル（AES-128のKnown Answer Test）で1ラウンドの出力を
  照合する。
  - 鍵スケジュールを紙に展開してRconの使い方を整理し、128/256ビット鍵でどこが異なるかをまとめる。


- RSAが広く使われている理由

  - RSAは1977年の提案以降、最初期に公開された公開鍵暗号であり、暗号化と署名の両方を一つの枠組みで実装できる点が評価されました。
  - 1980〜90年代にかけて標準化団体（PKCS、X.509、TLS、PGPなど）が次々に採用した結果、ほぼすべてのOS・ブラウザ・ハードウェアがデフォルトでサポートする状態が築かれました。

  - 成熟した安全性モデル：安全性が大整数の素因数分解困難性に帰着し、学術的解析が豊富。鍵長を伸ばすだけで耐性を調整しやすい。
  - 標準化と相互運用性：PKCS#1、TLS、S/MIME、OpenPGPなどの標準仕様がRSAを前提に整備され、異なる実装同士でも動作保証が容易。
  - 実装資産とハードウェア支援：長年にわたり最適化されたライブラリやHSM、スマートカード、TPMなどのハードウェアがRSAをネイティブサポート。既存インフラを維持するコストが低い。
  - 鍵配送の課題解決：対称鍵暗号の鍵共有問題を解消し、ハイブリッド暗号（RSAでセッション鍵を暗号化→AES等で本体通信）を可能にした。
  - 用途の広さ：暗号化とデジタル署名を同一数学的構造でカバーし、PKIの基盤として企業・行政システムに実装しやすかった。
  - 歴史的先行者利益：ECCや他方式が成熟する以前から普及しており、新興方式より互換性・保守性が重視された。

- 離散対数問題（DLP）とは？

  - ある巡回群における離散対数（指数）を求める問題のこと
  - 通常の対数では簡単に計算できる逆算が、特定の群（有限体など）では非常に難しい（計算量的困難性がある）という性質を利用しており、現代の暗号技術の基盤となっている。

- Diffie–Hellman はどう動作しますか？
  - 盗聴される可能性がある通信路（インターネットなど）を使って、2人だけで共通の「秘密の鍵」を作り出すための仕組み。
  - Diffie–Hellman鍵共有は、1976年に提案された「離散対数問題の難しさ」を使った仕組みで、第三者に知られずに共通鍵を作る方法です。暗号化に必要な鍵を、安全な通信路がなくてもオンラインで合意できます。
  -  1. 共有準備：大きな素数 p と「元（Generator）g」を公開。誰でも見られる。
  - 2. 秘密選択：アリスは秘密数 a、ボブは秘密数 b を選ぶ。これは他人に教えない。
  - 3. 送信：アリスは A = g^a mod p を計算してボブに送る。ボブも B = g^b mod p を計算してアリスに送る。A と B は公開されても構わない。
  - 4. 共通鍵生成：アリスは K = B^a mod p、ボブは K = A^b mod p を計算。実は両者の結果は g^(ab) mod p で同じ値になる。
  - 5. 安全性：第三者が A と B、p、g を知っていても、a や b（ひいては K）を求めるには離散対数問題を解く必要があり、現実的な時間では困難とされる。

- ElGamal の要点は？
  - エルガマル暗号は、ディフィー・ヘルマン鍵交換の仕組みを応用した公開鍵暗号方式です。
  - 離散対数問題の計算困難性を安全性の根拠としており、暗号化と復号に非対称な鍵ペア（公開鍵と秘密鍵）を使用します。

- DLP 系の弱点（欠点）を1つ挙げてください。
  - サブ指数時間アルゴリズム：有限体 DLP は指数より速いアルゴリズム（例：Number Field Sieve, Function Field Sieve）が存在するため、十分大きな素数でも安全余裕が削られます。結果として RSA と同様に巨大なパラメータが必要。
  - 構造を悪用した攻撃：特殊な素数や小さなサブグループを使うと、Pohlig–Hellman や小サブグループ攻撃で計算が大幅に楽になります。パラメータ選定の自由度が狭い。
  - 計算コスト：大きな有限体上での指数演算は重く、鍵交換・署名検証が ECC や現代的 SNARK 向けプリミティブより遅くなる傾向。
  - 量子耐性がない：大きな量子コンピュータが実現すると Shor アルゴリズムで DLP が多項式時間で解けるため、根本的な破り方が存在。
  - サイドチャネル耐性：指数演算を長時間行うため、タイミング・電力解析などのサイドチャネル攻撃面の露出が広い。

- デジタル署名の役割と重要性は？
  - デジタル署名は「このデータは確かに私が作りました」「途中で書き換えられていません」を証明する仕組みのこと。
  - 受け取った人は公開鍵で署名をチェックするだけで、送信者の本人確認（認証）と内容の改ざん検知（完全性）を同時に行えます。
  - これによりインターネットバンキングやソフトウェア配布、電子契約などを安心して利用でき、送信者が「送っていない」と後から言い逃れできない（否認防止）点も重要です。

- DSA の仕組みを説明してください。
  - DSA（Digital Signature Algorithm）は米国政府が標準化したデジタル署名の方式で、離散対数問題（Diffie–Hellman 系と同じ難しさ）を使って安全性を確保します。
  -  1. 公開の土台を決める：
    - 大きな素数 p と、その中でよい性質を持つ生成元 g を選びます。
    - さらに q という p-1 を割る小さめの素数も決めます。これらは誰が見てもOKな公開情報です。
  - 2. 鍵の準備：
    - 利用者は q 未満の数字 x を秘密鍵として選びます。
    - 公開鍵は y = g^x mod p。x（秘密鍵）を知られてはいけません。
  - 3. 署名の計算：メッセージ M を送るとき、送信者はハッシュ値 H(M) を計算し、ランダムな数 k（毎回新しく）で
      - r = (g^k mod p) mod q
      - s = (k^{-1} · (H(M) + x·r)) mod q
      - という手順で署名 (r, s) を作ります。k を使い回すと秘密鍵が漏れるので要注意。
  - 4. 検証：受信者は公開鍵 y を使って (r, s) が正しいか確かめます。
      - w = s^{-1} mod q、u1 = H(M)·w mod q、u2 = r·w mod q
      - v = ((g^u1 · y^u2) mod p) mod q
      - v が r と一致すれば署名は正しい（＝送り主が秘密鍵で署名した・途中で改ざんされていない）と判断できます。

#### 演習

1. 対称鍵 vs 非対称鍵の違いと、それぞれの実用例。

- 対称鍵暗号：暗号化・復号に同一の鍵を利用する。高速・単純だが鍵配送が課題。
  - 例：信頼できるチャネル内でのデータ送信。
- 非対称鍵暗号：公開鍵で暗号化、秘密鍵で復号する。鍵共有は容易だが計算コストが高い。
  - 例：PGP メール。受信者の公開鍵で暗号化し、受信者だけが復号。

2. Diffie–Hellman を用いたメッセージングの安全性向上の仕組み。

 - Diffie–Hellman は安全でないネットワーク上で共有秘密を合意できる。
 - 実運用ではメッセージングのエンドツーエンド暗号化の基盤となる。

3. SHA-256 と Poseidon の特徴と、Poseidon の利点を1つ。

- SHA-256 は衝突・原像攻撃への耐性と速度のバランスが良い。
- Poseidon は回路に親和的な設計で ZKP に適する。

4. メルクル木が大規模データ検証を効率化する理由。

- 葉〜根の経路ハッシュのみで**包含検証**ができるため、大規模データでも効率的に検証可能。
- ZK Rollupなどブロックチェーンのトランザクション検証に使われる。

5. Pedersen コミットメントがトランザクションのプライバシーを保つ方法。

- Pedersen は値を隠しつつ後で開示可能（ハイディング＆バインディング）。
- 機密送金で金額を伏せる用途など。

6. デジタル署名付き文書の真正性確認の方法。

- 署名者の公開鍵で検証する。検証成功は「対応する秘密鍵所持者が署名し、メッセージが改ざんされていない」ことを示す。

### Week3

### 演習

#### 楕円曲線入門

1. 楕円曲線の一般式は？

- 「Weierstrass（ワイエルシュトラス）形式」と呼ばれる次の形で表せます
-  y² + a₁xy + a₃y = x³ + a₂x² + a₄x + a₆
  - a₁, a₂, a₃, a₄, a₆ は係数で、曲線の形を決める値です。
- 実際の暗号では扱いやすいように、係数を変換して簡略化した「短縮版（short Weierstrass form）」を使うことが多く、
  - **y² = x³ + ax + b**
  - と書かれる。このとき判別式 Δ = -16(4a³ + 27b²) が 0 でないことが楕円曲線として成り立つ条件です。

2. 2点 P, Q の和 P+Q はどのように求めますか？

- 楕円曲線（短縮ワイエルシュトラス形 y² = x³ + ax + b）では、点同士の加法は「線を引いて反転させる」操作として定義されています。
- 具体的には、P と Q を通る直線を引いて曲線と交わる3つ目の点 R を探し、その点を x 軸で鏡映した点がP+Q になります（R の x 座標は同じで、y 座標に符号を付け替える）。

3. 加法における単位元は？

- 足し算の単位元は「足しても相手が全く変わらない数」のことです。
- ふつうの整数なら 0 がそれに当たり、5 + 0 = 5 のように元の数がそのまま残ります。
- 楕円曲線の点の足し算でも同じ考えで、特別な **「無限遠点 0」** を単位元とし、どんな点に足しても結果がその点自身になります。

#### ECC

1. ECC が RSA 等に対して持つ主な利点は？

- ECC (Elliptic Curve Cryptography/楕円曲線暗号) と RSA はどちらも公開鍵暗号だが、同等の安全性を達成するために必要な数学的難易度が異なる。
  - RSA は**大きな素数の積の分解困難性に依存する**
  - ECC は**楕円曲線離散対数問題の困難性に依存する**

- 1) キーサイズの短さ（ECC 256bit ≒ RSA 3072bit）→ 処理効率とメモリ削減
- 2) 同じセキュリティをより低い計算量・電力で実現でき IoT/- モバイルに適切
- 3) 証明書や署名のサイズ縮小で通信帯域を節約でき
- 4) 離散対数問題は既知のアルゴリズムでは大規模並列化しにくく量子以前でも優位性が高い
- 5) ECDH/ECDSA など複合プロトコルで鍵交換と署名を柔軟に設計できる点。

- 同等安全性で短い鍵長。計算・帯域・ストレージが軽い。

2. ECC の公開鍵はどのように秘密鍵から導出しますか？

- ECCの公開鍵生成は、有限体上の楕円曲線 E(F_p)、生成元 G、その位数 n というドメインパラメータが前提です。
- 秘密鍵 d (スカラー、整数) を乱数から選び、楕円曲線上での点の加法・倍算を用いて Q = d·G を計算することで公開鍵が得られます。

3. ECDLP とは？

ECDLP（Elliptic Curve Discrete Logarithm Problem／楕円曲線離散対数問題）は、楕円曲線暗号（ECC）が安全と考えられる根拠となる難問です。

有限体上の楕円曲線E(F_p) と生成元 G を用いて、秘密鍵 d を掛け合わせた点 Q = d·G から d を逆算することが ECDLP で、既知の効率的アルゴリズムが存在しません。RSA の素因数分解問題に相当する役割を果たします。  
⇨ Q と dG から dを求める(逆算する)ことが困難なこと

#### Schnorr と EdDSA

1. Schnorr 署名の利点は？

- シンプルな数式: s = k + e·x の1本で成立し、逆変換も容易なため実装・検証がしやすい。
- マルチシグ/アグリゲーション適性: MuSig2などのプロトコルで、複数人の署名を一回にまとめられ、ビットコインTaprootやZKプロジェクトで採用が進む。
- シンプル・効率的・線形性により集約が可能(マルチシグ集約が可能)。

2. EdDSA は従来の Schnorr と何が異なりますか？

- EdDSA（Edwards-curve Digital Signature Algorithm）は、Schnorr署名のアイデアをそのままに、Twisted Edwards曲線とハッシュ駆動の決定的ノンス生成、定められたエンコード規則でフォーマライズした“実用仕様”です。
- Ed25519/Ed448が代表例で、Schnorrとの差は主にどの曲線・乱数生成・エンコードを採用するかにあります。
- ねじれ Edwards 曲線を用い、乱数が決定的（鍵とメッセージから導出）。

#### ペアリングベース暗号

1. 楕円曲線暗号におけるペアリングとは？

- ペアリング（双線形写像）は、楕円曲線上の2つの点群 G1, G2 を別の有限体乗法群 GT に写す仕組みで、e(P + P', Q) = e(P, Q) · e(P', Q) のような線形性（双線形性）を持ちます。
- ECCそのものはペアリングを使わずとも成立しますが、この双線形を活かすことで BLS署名やzkSNARK（例: Groth16）、IDベース暗号など高度なプロトコルが実現できます。

  - 「点の足し算が、別の世界では掛け算に変身するスイッチ」とイメージします。e(P+P', Q) = e(P, Q) × e(P', Q) という形で、足し算が掛け算に変わるのがポイントです。
  - このスイッチを使うと、みんなの署名をひとまとめにしたり（マルチシグ）、証明をコンパクトにしたりできます。だからSNARKやBLS署名で大活躍するのです。

2. 双線形写像の3つの性質は？

- 双線形性: 片方の入力を足すと結果が掛け算に分配される性質（例: e(P+P', Q) = e(P, Q)·e(P', Q)）。これがあるので計算をまとめたり並べ替えたりできる。
- 非退化性: 特別な点（単位元）以外を入れると結果がつねに1以外になる性質。これで「意味のある情報」が失われず、証明や署名が壊れない。
- 効率的可算性: 実際に計算できること。Millerループや最終冪乗といったアルゴリズムで現実的な時間内に値を求められるから、プロトコルとして実装可能になる。

3. ペアリングで可能になる応用を1つ挙げてください。

- 複数の署名や証明を一度にまとめて検証できるようになる点がポイント。
- BLS署名が可能になる
  - 各参加者が同じメッセージへ署名しても、ペアリングのおかげで **署名を全部足し合わせた1本の署名 σ_total** にでき、検証側も e(σ_total, G) と **e(H(m), 公開鍵の合計) の2回だけでチェック可能** です。 **従来方式のように署名本数分の検証をする必要がなく**、ブロックチェーンのように大量署名が発生する場面で通信量と計算量を大幅に抑えられます。

#### KZG 多項式コミットメント

1. 多項式コミットメントの目的は？

- 多項式コミットメントは「ある多項式を作りました」と宣言（コミット）し、そのあとで「この多項式に特定の値を入れると結果はこうです」と証明できる仕組みです。
- 肝は「多項式そのものは渡さなくても、決めた結果が本物だとみんなが確かめられる」こと。
  - 例：「秘密のレシピ（多項式）から、特定の材料（入力）で作った料理（出力）が正しい」と他人に示せます。

- コミットメントは「封筒」。多項式を封筒に入れて封をし、中身を変えられないようにします（束縛性）。
- 評価証明は「この封筒の中身に材料xを入れるとyができます」という説明書。見る人は封筒を開けずに、説明書が正しいかチェックできます（完全性）。
- zkSNARKやPLONKでは、この仕組みがあるから大量の計算結果を小さな証明で共有できる。入力を変えずに証明だけで安全に伝えられる。

2. KZG で多項式と秘密値に対するコミットはどう計算しますか？

- 1. 多項式の準備: たとえば f(x)=a₀+a₁x+a₂x² の係数 (a₀,a₁,a₂) を決めます。
- 2. コミット計算: SRSに含まれる点 G, G^{τ}, G^{τ²} を係数で重み付けして足し合わせ、C = a₀·G + a₁·G^{τ} + a₂·G^{τ²} を計算します。これが多項式へのコミットで、封筒に相当します。
- 3. 秘密値（評価）の扱い: 例えば z に対して y = f(z) を主張したいときは、f(x) - y を (x - z) で割った商 q(x) を求め、同じSRSで W = Σ q_i · G^{τ^i} を計算します。これが証明（witness）です。
- 4. 検証: 誰でも e(C - y·G, H) と e(W, H^{τ - z})（別側のSRS点を使う）を比較して一致するかチェックでき、正しい評価なら成立します。実際にはペアリングを1回で済むよう整理されています。
- 5. 直感: コミット C は係数を書き換えると成立しなくなるので束縛性、W と y をセットで出さないと検証に通らないので完全性が確保されます。

もっと簡単に説明したバージョン

-  KZGコミットメントは「ひみつの算数（多項式）ノート」を封筒に入れて見せずにしまい、あとで「このページの問題に 3 を入れたら答えは 5 だよ！」と証明できる魔法の仕組みです。みんなは封筒の中を見なくても、その答えが本当かチェックできます。

- ひみつノートを書く: 多項式 f(x) を、たとえば f(x)=2+x みたいに係数で決めておく。
- 魔法の封筒を作る: セットアップでもらった「不思議な鍵（SRS）」を使い、係数と鍵を組み合わせて封筒 C を作る。ここにノートの中身がこっそり隠れる。
- 答えを先に計算: z=3 をノートに入れて計算すると y=5 が出る。この y をメモしておく。
- 正しいよという証明書を作る: f(x) - y を (x - z) で割ったときの商 q(x) を使って、もう一度 SRS を組み合わせ、証明書 W を作る。
- みんながチェック: 見る人は封筒 C・答え y・証明書 W を受け取り、同じSRSで「計算がほんとに合っているか」を計算。合っていれば「このノートに 3 を入れると必ず 5 になるんだ！」と信じてくれる。

3. KZG が効率的・簡潔とされる理由は？

KZG多項式コミットメントは.**「多項式を小さな封筒1つにまとめ、評価の正しさもたった1回のペアリング検証で確かめられる」**  d点が強みです。

「効率的・簡潔」と言われる理由は大きく以下の3つです。

- 証明サイズが常に一定: 多項式の次数に関係なくコミット（封筒）も評価証明も1つの曲線点で済み、通信量が O(1)。大きな計算でもデータが小さいまま。
- 検証がペアリング1回: 検証者はペアリング評価をほぼ1回するだけで正当性をチェックできる（実装によっては2回→まとめて1回に最適化）。これが Groth16 などの高速SNARKの背骨。
- シンプルな算術: 証明者は一度多項式を (x - z) で割って係数を SRS 点と掛けるだけ。複雑なFFTや追加の多段階手続きが不要で、実装やZK回路に組み込みやすい。

#### Trusted Setup

1. なぜ Trusted Setup は重要ですか？

rusted Setup（トラステッド・セットアップ）は、zkSNARKやKZGのような一部の暗号プロトコルを動かすために最初に行う特別な準備作業です。ここで作られた「共通の鍵（CRS/SRS）」をみんなが使うことで、あとの証明や検証がとても小さく速くなります。

ただし、この準備の途中で出てくる「毒性廃棄物（toxic waste）」と呼ばれる秘密情報が外に漏れると、悪い人がウソの証明を作れてしまうため、参加者みんながこのセットアップ手順を正しく行い、残った秘密を必ず破棄したと信頼できることが重要です。

2. zk-SNARK と Trusted Setup の関係は？

zk-SNARK は「とても小さな証明で巨大な計算をチェックできる」仕組みですが、その効率を得るために多くの方式（例: Groth16, PLONK, KZGベース）は最初に TrustedSetup と呼ばれる準備で共通鍵（SRS/CRS）を作ります。
 
この準備中に生まれる秘密パラメータ（毒性廃棄物）が完全に破棄されていれば、以後は高速・小サイズな証明を安心して使えます。反対に、誰かがその秘密をこっそり保持すると偽造証明を作れるため、セットアップ手順を信頼できることが zk-SNARK の安全性に直結します。

- 共有参照文字列（CRS）に依存。安全な生成・破棄が前提。
- 従来のPKIのキーセレモニーと全く同じ課題。鍵のライフサイクルの運用が肝。

3. Trusted Setup の課題は？

- 信頼性・透明性・分散化・運用コスト。

- 全員が正直だったと信じる必要がある：セレモニー中の秘密（毒性廃棄物）が誰かの手に残ると、偽の証明を作れてしまう。
- 大掛かりな準備が必要：多人数でのセレモニー、録画、監査、専用機材など手間とコストが高い。
- セットアップ失敗の検出が難しい：あとから「実は秘密を捨てていませんでした」と証明する術がほぼなく、一度疑いが生じると信頼回復が困難。
- プロトコルごとにやり直しが発生：回路専用セットアップでは、回路を変えるたびに再度セレモニーが必要になり、開発スピードを落とす。

### Weel4

#### 準同型隠蔽（Homomorphic Hiding）

1. 自分の言葉で説明：

- 「値を隠したまま、外から演算（足し算や掛け算の一部）ができる」仕組みのこと。
- 開示後の結果が平文演算と一致するような仕組み

- 準同型性：封筒の外で「加算（あるいは乗算）」など決められた演算をすると、中の秘密値にも同じ演算が反映されます。Pedersenコミットメントは足し算に対応する代表例。

---

#### 算術回路

そもそも算術回路とは？

プログラムの動きを「足し算・掛け算だけができる電気回路」のように表現したもの。

入力から出力までの計算手順を秩序立てて並べ、各ステップが有限体上の方程式として成り立つように設計する。

1. 算術回路に変換する目的：
   
- 「プログラムの実行の正しさ」「特定の多項式が条件を満たすか」数学的な検証問題に変換するため
- 複雑な計算を加算・乗算ゲートのネットワークに平坦化し、R1CS など次段の表現に移しやすくするため。

2. 主な構成要素：
   
算術回路そのものや、それが変換される制約システムは、主にゲートと制約によって構成されます。

- ゲート・ワイヤ・入出力ポート

- 1. ゲート/基本的な演算（Gates / Operations）
  - 算術回路の構成要素は、計算のロジックを表現する基本的な数学的操作（ゲート）です。
    - 算術回路は、あらゆる計算やプログラムのロジックを、加算（+） と 乗算（×） のような基本的な数学的操作の組み合わせとして表現します。
    - 初期のシステム（例：Groth16など）では、算術回路は主に加算と乗算の基本演算のみで構成されていました。これは、複雑な計算を表現するために多くの基本演算を組み合わせる必要があり、非効率的でした。
    - 最近の進展では、PLONKのような新しいプロトコルでは、カスタムゲートが導入されました。これにより、通常の加算/乗算以外のより複雑な演算（例：ビット演算、条件分岐、ルックアップテーブル、より複雑な数学的関数）を直接1つのゲートとして定義できるようになっています。
- 2. 制約システム（Constraint System）
  - 算術回路は、多くの場合、証明システムが検証しやすい代数的な制約のセットに変換されます。
    - zk-SNARKsの算術化（Arithmetization）は、**制約のセット（set of constraints）**として表現されることが一般的です。
    - 最も一般的に使用される制約システムの一つが、**R1CS（Rank 1 Constraint System）**です。
      - R1CSでは、すべての計算が「（A）$\times$（B）＝（C）」という形式の制約のセットとして表現されます。
      - ここで、A、B、Cは、回路の入力値、中間値、出力値などの変数の線形結合です。
    - このR1CS形式は、さらに **QAP（Quadratic Arithmetic Program）** と呼ばれる多項式のセットに変換されます。Pinocchio（最初の実用的なzk-SNARK）もこのQAPに基づいていました。
  - Circomのような回路記述言語では、プログラムが必ず「$A \times B + C = 0$」の線形結合の制約となるように記述されます。
- 3. ワイヤー値（Wire Values）/ 変数
  - 回路を流れる中間的な計算結果や、入力・出力される値も構成要素です。
    - 回路内の演算（ゲート）は、入力された値（変数）に対して実行されます。証明者（Prover）は、秘密の値である**ウィットネス（$w$）**を知っていることを証明します。検証者（Verifier）は、このウィットネスを用いて計算された関数$\mathcal{F}$の結果が、公開された出力$y$と等しいこと、すなわち$\mathcal{F}(x; w) = y$であることを証明を通して確認します。
    - VOLEベースのZKPでは、IT-MACsが、計算を表す算術回路またはブール回路内の**認証されたワイヤー値（authenticated wire values）**へのコミットメントとして使用されます。

- 算術化（Arithmetization）のプロセス
  - 算術回路は、ZKPプロトコルで検証できるように、計算全体を代数的な形に変換する算術化プロセスの中核を担います。
    - 1. 高水準言語で書かれた計算ロジック（プログラム）を、CircomのようなZK DSL（ドメイン固有言語）やライブラリを用いて記述します。
    - 2. この記述されたプログラムが、算術回路にコンパイルされ、制約システム（通常はR1CS）として表現されます。
    - 3. この制約システムが、多項式（QAPなど）に変換され、証明者がこの多項式に関する数学的な主張（例：多項式が特定の根を持つこと）を検証者に証明することで、元の計算の正しさを保証します。

（主な構成要素）:
- 入力ワイヤ：証明したい値（公開入力）と、秘密にしたい値（秘密入力）を回路内に取り込む通路。
- 内部ワイヤ：途中計算の結果を次のゲートへ渡す中間線。制約が互いに整合するかをチェックする対象。
- 加算ゲート：二つのワイヤ値を足し合わせて次のワイヤへ送る装置。線形制約を表現する基本部品。
- 乗算ゲート：二つのワイヤ値を掛け合わせ、非線形の関係を作る装置。証明の複雑さは主に乗算数で決まる。
- 定数ワイヤ／定数ゲート：有限体の特定値を注入する部品。モジュラー減算や係数付き演算に使用。
- 出力ワイヤ：最終結果を公開部分へ出す通路。検証者が期待する値と一致することが制約で保証される。
- 制約（例：R1CSのA・B・C行列、PLONKの多項式制約）：各ゲート・ワイヤの関係を方程式で縛る仕組み。回路=制約集合と同義。
- 選択子／カスタムゲート（上級）：よく使う演算をまとめるための係数やルックアップ。回路を小さく高速にする拡張要素。

---

#### R1CS(Rank-1 Constraint System：ランク1制約システム)

1. R1CS とは：
  
- R1CS（Rank-1 Constraint System／ランク1制約システム）は、プログラムの「正しく計算できているか」を有限体上の一次方程式の積で表す方式です（行列・ベクトルの積で記述）。
- たとえば 〈a, w〉 × 〈b, w〉 = 〈c, w〉 のように、ワイヤ値 w の線形結合どうしを掛け合わせて別の線形結合と一致させる形に整えます。これにより「足し算と掛け算だけの算術回路」が厳密な制約集合へ変換され、Groth16 や PLONK など多くの zk-SNARK で扱いやすくなります。

- R1CS は「計算がちゃんとできたかどうか」をチェックするための、足し算と掛け算だけで作った仕組みです。
- ゲームのスコア表みたいに、いくつかのルール（制約）を全部クリアできたら「正解！」になります。
  - 3つの箱（A・B・C）に数字カードを並べる。
  - A箱の数字カードを足してから B箱の数字カードを足し、それぞれの合計を掛け算する。
  - その結果が C箱のカードを足し合わせた数とぴったり同じなら、そのルールはクリア。
  - たくさんあるルール全部でこれが成功すれば「計算はまちがっていません」と言える。

2. 重要な理由：
 
- R1CS（Rank-1 Constraint System）は、ゼロ知識証明（ZKP）の分野、特にzk-SNARKs（Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge）において、**計算を検証可能な数学的表現に変換するため**の極めて重要な基盤技術です
  - 1. ゼロ知識証明システムの主要な算術化戦略である
    - R1CSは、多くのzk-SNARKsのプロトコルで採用されている一般的な算術化（Arithmetization）戦略です。
    - 算術化の役割：算術化とは、デジタル回路や計算モデルの配線やゲート操作を、数学的な表現に符号化するプロセスであり、証明の生成に適した形式に変換する目的で行われます。
    - 計算の表現：R1CSは、複雑な計算（例えばPython関数など）を、効率的に検証可能な線形方程式の制約の集合として表現する方法を提供します。この制約が満たされていることが、計算が正しく実行されたと見なされるための基礎となります。
  
  - 2. zk-SNARKの簡潔性（Succinctness）を実現する鍵となる
    - R1CSは、zk-SNARKの重要な特性である「簡潔性」と「高速検証」を可能にするための中間表現として機能します。
    - QAPへの変換：zk-SNARKのプロセスにおいて、R1CSで表現された計算は、バックエンドフェーズでQuadratic Arithmetic Program (QAP) を形成する多項式方程式のセットに変換されます。
    - 効率的な検証：このR1CSからQAPへの変換は、SNARKの作成において不可欠な要素です。行列演算を多項式方程式に符号化することで、元の回路の実行トレースをより簡潔に表現し、検証者はR1CSのすべての計算を実行することなくQAP検証方程式を効率的にチェックできます。これにより、検証者の実行時間を準線形に短縮し、大幅な高速化が実現します。

  - 3. 広く採用されている証明システムの基礎である
    - R1CSは、ゼロ知識証明の分野で最も広く使用されているいくつかのプロトコルやツール群の基盤となっています。
    - 主要プロトコルの採用：R1CSは、Groth16 や Lurk など、多くのzk-SNARK実装で利用されています。
    - 開発ツールの焦点：ゼロ知識証明のための多くのドメイン固有言語（zkDSL）やライブラリは、R1CSをターゲットとしています。
      - Circom は、算術回路をR1CSにコンパイルするために設計された古典的な言語です。
      - O1JS は、R1CSから導出されたゼロ知識証明の生成と検証に熟練したライブラリです。
      - Arkworks や Gnark などの主要なZKPライブラリは、R1CS制約をサポートし、開発者がR1CSインスタンスを構築するための構成要素（ガジェット）
      を提供しています。

  - このように、R1CSは、計算の正確さを証明するための汎用的な数学的フレームワークを提供し、特にzk-SNARKsの実用性と効率性の根幹を担っているため非常に重要です。

---

#### QAP

1. R1CS を QAP にする目的：

- 多項式表現に落とし込み、ゼロ知識証明（zk-SNARK）を効率的かつ簡潔に検証可能にするため。
- 複雑な計算を「行列の制約」という形（R1CS）から、「多項式の方程式」という形（QAP）に変換することで、検証者（Verifier）の作業を劇的に少なくするため
   
2. 生成プロセスでの役割：
   
- R1CS は「足し算して掛ける」形の制約ですが、そのままだと証明サイズを小さくするのが難しい。
  - R1CSはバラバラの制約集合となっている
  - これを一本のが多項式に変換する
- そこで R1CS 全体を一本の多項式等式にまとめられる QAP（QuadraticArithmetic Program）へ変換します。
- これによって **「多項式コミットメント＋ペアリング」** で一気に検証できるようになり、Groth16 などの zk-SNARK で小さく高速な証明が作れます。

3. 多項式が中心となる理由：
 
- **回路全体が正しく実行されたかどうかという多数の制約**を、たった一つの数学的なチェックに変換・集約できるという性質を持っているから！
- - 評価・補間など計算道具が豊富だから

---

#### Pinocchio (ピノキオ)プロトコル

2013年に発表されたzk-SNARKプロトコルの一つです。

Pinocchioは、この「zk-SNARKs」という概念を、理論だけでなく現実の計算（汎用計算）に適用するための道を切り開いたプロトコルです。

1. 実用化への前進とされる理由：

- 証明したい計算（例：C言語のプログラム）を数学的に検証可能な形式に変換するプロセス、**算術化（Arithmetization(アリスメティゼーション)）**において革新的なアプローチを採用した。
- R1CSとQAPの使用：Pinocchioは、計算を表現するためにR1CS（Rank-1 Constraint System）を採用し、さらにそれをQAP（Quadratic Arithmetic Program）へと変換するアプローチを採用しました
- R1CSとQAPを用いて実用的な非対話型の簡潔な証明方法を示した。
   
2. QAP の用い方：

- 回路→R1CS→QAP→証明生成
- QAP の多項式構造とペアリングを組み合わせ、短い証明を生成・検証している。
-「すべての制約を一本化してコミットし、ペアリング 1〜2 回で検証する橋渡し」として使用している

3. ペアリングの役割：
   
- 検証者は楕円曲線ペアリングを使用してQAP方程式をチェックすることができる。
- ペアリングを利用することにより、**元の計算の複雑さ（回路のサイズ）に関係なく、短時間で検証することが可能となった。**
- 「多項式で表現された複雑な計算の正しさを、迅速かつ秘密を漏らさずに証明するために、検証者が使用する暗号学的定規」のようなもの
- 証明の正当性を効率よく検査するための基盤演算を提供している

---

#### Groth16

1. 人気の理由：

- ZKPプロトコルの中でも特に効率性と簡潔性に優れているため
  - 1. 証明サイズ（Proof Size）が極めて小さい
    - 簡潔な証明：Groth16は、わずか3つの群要素からなる最小の証明サイズを実現しました。
    - オンチェーンコストの削減。ガス代などの削減になる
  - 2. 圧倒的に高速な検証時間
    - 高速な検証：Groth16は、3つのペアリング操作（楕円曲線上の数学的操作）を含む高速な検証を実現します
    -  ブロックチェーンでの利便性：zk-Rollupなどのスケーリングソリューションにおいて、Ethereumのようなベースレイヤーのスマートコントラクト上で検証を行う際、検証時間が速いことは即時の取引確定と低コストに直結するため、理想的とされています
  - 3. 幅広い採用と既存エコシステムとの互換性
    -  代表的な採用事例：Groth16は、匿名通貨ZcashのSaplingアップグレード や、分散型アプリケーションをプライベートに構築するためのプラットフォームAleo など、多くのプロジェクトで採用されています。
    - 開発ツールのサポート：Circom、Noir、Gnark、Arkworks、SnarkJS、ZoKrates などの主要な開発ライブラリやツールキットがGroth16をバックエンドとしてサポートしており、エコシステムが成熟している点も強みです。 
    -  中間表現との親和性：Groth16は、広く使われている算術化スキームであるR1CS（Rank-1 Constraint System）を中間表現として使用します。

2. 長所と短所：

- 長所：効率・簡潔さ(上述の通り)。
- 短所：**回路固有の Trusted Setup が必要(つまり回路ごとにセットアップをやる必要がある)**。
   
3. Pinocchio との違い：

- Pinocchio（2013）は QAP＋KZG を用いた初期の実用 zk-SNARK。
- Groth16（2016）は Pinocchio を洗練し、証明サイズ・検証コスト・セットアップサイズを大幅に圧縮しました。   
- セットアップ要件の性質にも差異。

主な違い

- 証明サイズ: Pinocchio は 3ペアリング命題を支える 8 要素程度（G1×6, G2×2）。Groth16 は G1×2 + G2×1 の計3要素で済み、通信量が約半分以下。
- 検証コスト: Pinocchio はペアリング 3回＋追加乗算が必要。Groth16 はペアリング 2回（最適化でほぼ2回）に減り、検証器が軽量。
- CRS（SRS）構造: Pinocchio は証明・検証で別々の多数の要素を要求。Groth16 は「Powers of Tau」を分離し、大小2段階のセットアップで汎用性を高めつつ総サイズも縮小。
- Prover 計算: Groth16 は QAP 評価をより効率的に分解し、FFT フレンドリーな実装で Pinocchio より高速。メモリ使用量も少ない傾向。
- セキュリティ証明: Groth16 はペアリング方の最小構成に伴い、Knowledge of Exponent Assumption（KEA）下で厳密な安全性証明を提供。Pinocchio も同系統だが、Groth16 のほうが形式化が進んだ。
- 実装・採用: Groth16 は Zcash や多くの zk-SNARK システムのデファクト標準。Pinocchio は研究史的なマイルストーンとして認知されつつ、実用では Groth16 に置き換えられた。

---

#### PLONK

PLONK（Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge）は、2019年 に発表されたzk-SNARKs（ゼロ知識簡潔非対話型知識論証）の一種であり、従来のSNARKsが抱えていた大きな課題を解決し、ゼロ知識証明の応用範囲を劇的に広げた重要なプロトコルです。

1. Groth16 に対する利点：
  
- ユニバーサル・更新可能セットアップを導入したことで回路ごとの再セットアップが不要となった。
- モジュール性も高い。

- Universal/Updatable SRS: 一度の「Powers of Tau」セットアップで多数の回路を再利用可能。回路変更のたびにセレモニーをやり直す Groth16 と比べ、開発サイクルが速く、運用コストが低い。
- 回路定義の柔軟性: PLONKish IOP により、足し算・掛け算だけでなく置換（Permutation）やルックアップ（Lookup）、カスタムゲートを自然に組み込める。複雑な計算でも制約数を圧縮しやすい。
- 拡張性: PLONK を基盤に Turbo/UltraPLONK、Halo2、Plonky2 など多様な改良版が登場。レンジチェックや Poseidon などを効率化する拡張が揃い、モダンな ZK プロジェクトで採用しやすい。
- 開発者エコシステム: Circom/PSE 版 Halo2 など、PLONK系ライブラリが充実。回路 DSL・証明システム・OSS 事例が豊富で、学習・実装コストを抑えられる。
- Trusted Setup の透明性向上: Updatable SRS なので新たな参加者が貢献して古い「毒性廃棄物」への信頼を補強できる。Groth16 の回路専用セットアップより不信時のリカバリが容易。

2. なぜ回路ごとのセットアップが不要か：
  
- 普遍的（Universal）で更新可能な構造化参照文字列（SRS）を導入したから
  - 一度のセットアップで所定サイズ以下の任意回路を扱える「普遍的」な SRS を用いるため。
  - このSRSは所定サイズ以下の全てのプログラムに対して扱える

### Week 5

#### 個別質問

1. nullifier は何をするもので、なぜ重要ですか？

- Nullifierの最も重要な役割は、同じゼロ知識証明が二度使用されることを防ぐこと
- ダブルシグナリング防止（Prevent double signaling）」と呼ばれる機能を実現するために設計された一意の識別子です
- Nullifier（ナリファイア）は「この秘密（例：ある入金メモ）を一度使ったことがあるか」を判定するための識別子です。秘密値と回路内の追加データからハッシュのように生成され、同じ秘密を再利用しようとすると同じ nullifier が出力されます。

2. trapdoor(トラップドア) は何をするもので、なぜ重要ですか？

- Semaphore（セマフォ）アイデンティティを構成する非常に重要な要素の一つです。
- 1. trapdoorの役割（何をするものか）
  - アイデンティティの構成要素: Semaphoreの各アイデンティティは、次の3つの要素で構成されています。
    - 1. trapdoor (秘密の値)
    - 2. nullifier (秘密の値)
    - 3. commitment (公開の値)
  - アイデンティティコミットメントの生成: trapdoorとnullifierという2つの秘密の値のハッシュは、「アイデンティティシークレット」と呼ばれます。このアイデンティティシークレットをさらにハッシュ化したものが、**「アイデンティティコミットメント」**となります。 アイデンティティコミットメントは、プロトコル内で人々を表すために使用される公開値であり、Ethereumアドレスのようなものと考えることができます

- 2. なぜ重要か
  - trapdoorは、匿名性を保ちながらグループ内での行動を証明するために不可欠な秘密鍵のような役割を果たします。
    - 1. 匿名シグナルの認証: trapdoorを含む秘密の値は、Semaphoreのゼロ知識証明を生成し、シグナル（メッセージ、投票、承認など）を認証するために使用されます。 これらの秘密の値は、Ethereumの秘密鍵のようなものとして捉えられます。
    - 2. 証明生成の基盤: ユーザーが匿名でメッセージを送信する際、この秘密の値（trapdoorとnullifier）を用いて自身がグループのメンバーであることの証明（メンバーシップ証明）を作成します。
    - 3. プライバシー保護: 証明を生成するために、ユーザーは自分のプライベートなアイデンティティ情報（秘密の値）を使用する必要があります。そのため、証明の生成は、クライアント側の暗号化のように、ユーザー自身のデバイス上の保護された環境でローカルに行われることが推奨されます。これにより、元のアイデンティティを明かすことなく、検証可能で匿名なメッセージを発信できるというSemaphoreの主要な目的が達成されます

3. Semaphore / UniRep / RLN を比較してください。

Semaphore、UniRep、およびRLNは、いずれもゼロ知識証明（ZK-Proof）技術を活用したプロトコルであり、主に匿名性とプライバシー保護を目的としていますが、それぞれ異なる機能と役割を持っています。

| 特徴 | Semaphore | UniRep (Universal Reputation) | RLN (Rate-Limiting Nullifier) |
|------|-----------|--------------------------------|--------------------------------|
| **目的** | 匿名シグナリング：グループのメンバーであることを証明し、元のアイデンティティを明かすことなくメッセージ（投票、承認など）を発信すること。二重シグナリング（二重投票など）の防止。 | 匿名ユーザーデータ/評判管理：匿名IDを通じてユーザーデータを安全に管理し、ユーザーのプライバシーを保護しながらトラストレスなやり取りを可能にする。ZKアプリケーションの強力なメモリ層として機能する。 | 匿名環境でのスパム防止：匿名性を維持しながら、システムとのやり取りの頻度（レート制限）を制御する。 |
| **主要技術** | ゼロ知識プロトコル (ZK)。バイナリMerkle Tree (匿名性集合)。 | ゼロ知識プロトコル (ZK)。Epoch Keys (短命な識別子) を使用して匿名でデータを変更・証明。 | ZKガジェット/プロトコル。Shamir's Secret Sharing (SSS) スキームを利用。グループメンバーシップ証明にSemaphoreを利用。 |
| **機能/焦点** | グループメンバーシップの証明と匿名メッセージの発信に焦点を当てる。グループはオフチェーン/オンチェーンで管理可能。 | ユーザーのプライベートデータの保存と取得に焦点を当てる。評判（データ）には、好み、活動、所有権など様々な側面を含める。ユーザーがデータの開示や変更を完全にコントロールする。 | レート制限メカニズムを提供する。もしユーザーが設定された制限（例：15秒間に1メッセージなど）を超えてメッセージを送信すると、Shamir's Secret Sharingにより秘密鍵が再構築され、ペナルティ（ステークの没収など）が課される。 |
| **関連性** | Ethereum上のdApps向けのシンプルで汎用的なプライバシー層として設計されている。UniRepはSemaphore上に構築されている。BandadaはオフチェーンのSemaphoreグループ管理を簡素化するインフラストラクチャを提供する。 | Semaphoreの上に構築された評判システムまたはプロトコルである。匿名ID（エポックキー）を使用してユーザーデータ変更を**アテスター（アプリケーション）**が安全に証明する。 | 匿名環境の健全性を維持するためのツールであり、Semaphoreが提供する匿名性セット（グループメンバーシップ証明）を利用する。RLNは、オークションの入札制限や匿名チャットでのDoS攻撃防止などに使用できる。 |

--------------------------------------------------------------------------------

- 1. Semaphore (匿名シグナリングプロトコル)
  - Semaphoreは、ユーザーがグループの証明可能なメンバーであると同時に、元のアイデンティティを明らかにすることなくメッセージを送信できるように設計されています。
    - 匿名性とグループ：Semaphoreアイデンティティは、2つの秘密の値（trapdoorとnullifier）と1つの公開値（identity commitment）で構成されます。これらのアイデンティティコミットメントがMerkle Tree（匿名性集合/グループ）の葉として登録されます。
    - 二重シグナリング防止：Semaphoreは、nullifier hashという値を使用して二重シグナリングを防ぐメカニズムを提供します。これは、アイデンティティの秘密鍵と特定のスコープ（テーマ）のハッシュに基づいて生成され、同じユーザーが同じスコープで二度証明を作成することを防ぎます。
    - 利用シーン：プライベート投票、内部告発（Whistleblower applications）、匿名DAOなど、匿名でグループの一員として行動したい場合に利用されます。

- 2. UniRep (匿名ユーザーデータ/評判管理プロトコル)
  - UniRepは、Semaphoreの上に構築されたプロトコルであり、匿名ユーザーデータと評判の管理を主な機能とします。
    - データと匿名性：UniRepは、ユーザーごとに少量のデータ（現在の実装では200バイト）を匿名で保存することを可能にします。アプリケーションは、ユーザーのアイデンティティを知ることなく、短命な匿名識別子であるエポックキー (epoch keys) を使用してデータを変更できます。
    - ユーザー主権：ユーザーデータはパブリックな場所に保存されますが、暗号化されており、ユーザーの同意なしにデータが明らかにされたり変更されたりすることはありません。これにより、ユーザーはプラットフォームにデータを貸し出すのではなく、データを所有する状態を実現します。
    - 相互運用性：ユーザーデータは公開されているため、どのアプリケーションでもそのデータに基づいて証明を作成し、相互運用性を高めることができます。
    - 利用シーン：匿名レビュー/推薦、ピアツーピアの匿名融資（信用スコアとして評判データを利用）、匿名マーケットプレイス、匿名グループチャット、医療記録の管理など、ユーザーの評判やデータ履歴が重要となるアプリケーションの基盤となります。

- 3. RLN (レート制限ヌリファイア)
  - RLNは、匿名環境におけるスパムやDoS攻撃を防ぐことを目的としたプロトコルまたはZKガジェットです。Semaphoreが提供する匿名シグナリングの能力を土台として、その上にレート制限のレイヤーを追加します。
  - シャミアの秘密分散 (SSS) の利用：RLNの核となるのは、Shamir's Secret Sharing (SSS) スキームです。ユーザーがメッセージを送信する際、ZK証明と共にシークレットシェアが公開されます。
  - レート制限違反の検出：ユーザーが設定されたレート制限（例：特定の時間またはイベント内でのメッセージ送信回数）を超えてメッセージを送信すると、複数のシークレットシェアが公開されます。

4. Semaphore / UniRep / RLN で使われる主要な暗号概念は何ですか？

- これら3つのプロトコルに共通する最も重要な暗号概念は、ゼロ知識証明 (ZKP) 。
- これらのプロトコルでは、開発者が最小限の労力でZKPを生成・検証できるよう、Solidityコントラクト、Circom回路、JavaScriptライブラリが提供されています。
- Semaphore (匿名シグナリング) の主要暗号概念
  - EdDSA (エドワーズ曲線デジタル署名アルゴリズム)
  - Merkle Tree (マークルツリー)
  - Poseidon ハッシュ関数
  - Nullifier (ヌリファイア)
- UniRep (匿名データ/評判管理) の主要暗号概念
  - エポックキー (Epoch Keys)
  - 非対称/対称暗号化
  - Merkle Tree (データのネスト)
  - zk-ECDSA
- RLN (レート制限ヌリファイア) の主要暗号概念
  - Shamir's Secret Sharing Scheme (SSS)
  - シークレットシェアの公開
  - Merkle Tree
  - Circom Circuit

#### 一般質問（各プロジェクトごとに）

##### Semaphore

- 1. 動機と機能：何のために作られ、何を実現しますか？
  - 動機
    - 権力の制限（Limit Power）：  
      - 多くの情報を持つ者（権力者）がその知識を基に力を得ることを防ぎます。
      - 個人のデータやアイデンティティをプライベートに保つことは、権力を分散させることにつながります。
    - 言論の自由の促進（Promote Freedom of Speech）：
      - 発言や執筆によって報復を受けることへの恐怖を取り除くことで、自由な思考を促します。
      - 考えを検閲する第一歩は、その著者を攻撃することであるため、匿名性はこれを防ぎます。
    - 評判の保護（Safeguard Reputation）：
      - 人々のアイデアが「誰が言ったか」ではなく、「何を言ったか」に基づいて評価されることを可能にします。
      - これにより、客観的な視点からアイデアを評価することができます。
    - メッセージの独立性：
      - アイデアをその所有者のアイデンティティから切り離すことを可能にします。
      - メッセンジャー（発信者）のアイデンティティを保護することが、メッセージそのものよりも重要になる場合があります
  - 機能
    - 匿名シグナリング：
      - ユーザーがグループに参加し、元のアイデンティティを明かすことなく、メッセージ、承認、または投票などのシグナルを送信することを可能にします。
    - グループメンバーシップの証明：
      - ユーザーが特定のグループのメンバーであることを検証可能なゼロ知識証明を作成します。
      - このグループは匿名性集合として機能します。
    - 二重シグナリングの防止：
      - 同じ証明が二度作成されること（二重投票など）を防ぐためのメカニズムを提供します。
      - このために、アイデンティティの秘密鍵と特定のスコープ（テーマ）のハッシュであるnullifierを使用します。

- 2. ユースケース：非技術者にも説明できる実用例を挙げてください。
  - プライベートな意思決定（Private Voting）：
    - 特定のDAO（分散型自律組織）のメンバーだけが参加できる匿名投票。
    - 誰が投票したかは分からないが、その人が正当なメンバーであり、二重に投票していないことは証明できます。
  - 内部告発アプリケーション（Whistleblowing Applications）：
    - 会社や組織の従業員が、報復を恐れることなく不正行為や問題を匿名で報告するシステム。
  - 匿名DAO/コミュニティ：
    - 組織のメンバー（特定のNFTやSBTを所有する人々、または企業の従業員など） が、現実の評判と切り離された環境で、安心してアイデアを投稿したりチャットしたりできる場。
  - オンライン実験：
    - ユーザーが匿名で質問に答えたり、メッセージを送信したり、集団でアート作品を制作したりする実験的なアプリケーション。

- 3. ハードル：採用に向けた課題や改善点は？
  - 課題
    - 1. 技術の複雑性：
      - ゼロ知識証明などの暗号技術は、数学や暗号のバックグラウンドがない人々にとって理解が難しく、技術の複雑性が大きな課題となっています。
    - 2. 開発ツールの不足（過去の状況）：
      - シンプルで実用的な開発ツールの利用可能性がまだ限られており、技術的な概念をさらに抽象化するステップが必要です。
    - 3. 人々の無関心：
      - プライバシーや匿名性がなぜ重要なのか、データがどのように使われているのかについての意識と教育が不足していることが、人々の無関心につながっている可能性があります
  - 改善点と今後の方向性
    - 1. グループ管理インフラストラクチャの構築：
      - グループの作成、メンバーの追加、削除、更新などを管理するためのインフラストラクチャ（クラウドまたはセルフホスト型のダッシュボード）を構築するというアイデアがあります。
      - Bandada はこのギャップを埋めるインフラストラクチャであり、オフチェーンのSemaphoreグループの管理を簡素化します。
    - 2. 分散型グループのためのコントラクト：
      - オンチェーンの属性（SBTやNFTの所有、または特定の資産額など）に基づいて、外部の承認なしにユーザーが直接グループに参加できるアテステーションコントラクト（オンチェーンのスマートコントラクト）を作成すること。
    - 3. 開発者体験とドキュメントの改善：
      - 目標が明確で、主要な価値観や概念が容易に伝わるようにすること、また、コードの品質を高めることが、コミュニティの成長と技術の採用に不可欠です。教育的なウェブサイトを作成することを含め、開発者体験とドキュメントの改善を継続しています。
    - 4. コミュニティの強化：
      - グラントプログラムなど、強力なコミュニティを育成するための施策を展開しています。

- 4. 回路の読み取り

https://github.com/semaphore-protocol/semaphore

https://deepwiki.com/semaphore-protocol/semaphore

```circom
pragma circom 2.1.5;

include "babyjub.circom";
include "poseidon.circom";
include "binary-merkle-root.circom";
include "comparators.circom";

// Semaphore回路は3つの主要な部分に分けることができます。
// 第一部では、Semaphoreアイデンティティの生成を行います。
// つまり、公開鍵とそのハッシュ（コミットメントと呼ばれる）の生成で、
// これは公開値として使用されます。
// 第二部では、アイデンティティコミットメントがMerkle木（Semaphoreグループ）の
// 一部であるかどうかを検証します。つまり、メンバーシップ証明の検証を行います。
// 第三部では、nullifierの生成を行います。これは証明のスコープと
// 公開鍵の導出に使用される秘密（秘密スカラー）のハッシュです。nullifierは
// 同じ証明が二度検証されることを防ぐために使用されます。
// 最後に、回路にはメッセージが含まれます。これはユーザーが定義する
// 任意の匿名値、またはその値のハッシュです。
template Semaphore(MAX_DEPTH) {
  // 入力シグナル
  // 入力シグナルは'message'と'scope'を除いて全てプライベートです。
  // secretは、EdDSA秘密鍵から生成されるスカラーです。
  // 秘密鍵の代わりに秘密スカラーを使用することで、この回路では
  // こちらで定義されている公開鍵生成のステップ1、2、3をスキップできます：
  // https://www.rfc-editor.org/rfc/rfc8032#section-5.1.5
  // これにより回路がより効率的でシンプルになります。
  // アイデンティティがどのように生成されるかについて詳しくは、
  // Semaphoreアイデンティティパッケージを参照してください：
  // https://github.com/semaphore-protocol/semaphore/tree/main/packages/identity
  signal input secret;
  signal input merkleProofLength, merkleProofIndex, merkleProofSiblings[MAX_DEPTH];
  signal input message;
  signal input scope;

  // 出力シグナル
  // 出力シグナルは全て公開です。
  signal output merkleRoot, nullifier;

  // 秘密スカラーは素数サブグループ位数'l'内でなければなりません。
  var l = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

  component isLessThan = LessThan(251);
  isLessThan.in <== [secret, l];
  isLessThan.out === 1;

  // アイデンティティ生成
  // 回路では、Baby Jubjub（https://eips.ethereum.org/EIPS/eip-2494）を使用して
  // 秘密からEdDSA公開鍵を導出します。
  // これは基本的に2つの座標を持つ点に過ぎません。
  // その後、公開鍵のハッシュを計算し、これがコミットメント、
  // つまりSemaphoreアイデンティティの公開値として使用されます。
  var Ax, Ay;
  (Ax, Ay) = BabyPbk()(secret);

  var identityCommitment = Poseidon(2)([Ax, Ay]);

  // メンバーシップ証明の検証
  // 出力として渡されるMerkle rootは、Merkle proofの入力を通じて
  // 回路内で計算されたものと等しくなければなりません。
  // 'BinaryMerkleRoot'テンプレートがどのように動作するかについて詳しくは、
  // https://github.com/privacy-scaling-explorations/zk-kit.circom/blob/main/packages/binary-merkle-root/src/binary-merkle-root.circom
  // を参照してください。
  merkleRoot <== BinaryMerkleRoot(MAX_DEPTH)(identityCommitment, merkleProofLength, merkleProofIndex, merkleProofSiblings);

  // nullifier生成
  // nullifierは、特定のスコープと特定のアイデンティティによって生成された
  // 証明を本質的に識別する値です。これにより、外部から同じnullifierを持つ
  // 別の証明が既に生成されているかどうかを誰でもチェックできます。
  // このメカニズムは、例えば二重支払いや二重投票を防ぎたい場合に
  // 特に有用です。
  nullifier <== Poseidon(2)([scope, secret]);

  // messageは実際には回路内で使用されません。
  // messageに適用される二乗は、Circomのコンパイラに制約を追加させ、
  // 攻撃者によってその値が変更されることを防ぐ方法です。
  // 詳細はこちら：https://geometry.xyz/notebook/groth16-malleability
  signal dummySquare <== message * message;
}
```

回路の要点（行順に追跡）

- pragma circom 2.1.5：Circom v2.1.5の構文・標準ライブラリ前提。コンパイル時はcircom@2.1.5で固定推奨。
- include群：BabyPbk（EdDSA公開鍵生成）、Poseidon、BinaryMerkleRoot、LessThan(251)などを外部テンプレートとして利用。
- 入力信号
  - secret: BabyJub上の秘密スカラー。EdDSA秘密鍵のラストステップと同義。
  - merkleProofLength: 実際の証明（ツリーの深さ）がMAX_DEPTHより短い場合に使う。
  - merkleProofIndex: 挿入時の葉インデックス（経路ビット列としてBinaryMerkleRoot内部で利用）。
  - merkleProofSiblings[MAX_DEPTH]: 各レベルのシブリングハッシュ。
  - message/scope: messageは形だけの入力、scopeはnullifier計算に使われる公開値。
- 出力信号
  - merkleRoot: 証明の結果得られたグループルート（公開入力として検証者に渡す）。
  - nullifier: Poseidon(scope, secret)の結果。外部で重複チェックに使用。

主要制約の解説

1. スカラー範囲チェック：LessThan(251)は251ビット未満の数値比較に特化（BabyJubのlが約252ビットなのでギリギリ）。isLessThan.out === 1で強制。
    - 改善提案：LessThanは上限を2^nとして扱うため、定数lを明示的に比較する実装に置き換えるとより厳密（例：Num2Bits(252)＋加算チェック）。
2. 公開鍵生成：BabyPbk()(secret)でBabyJub上の[secret] * BasePointを計算し、Ax, Ayを得る。
    - ここでsecretがl未満であることで曲線上有効点が保証される。
3. コミットメント計算：Poseidon(2)([Ax, Ay])はt=2のPoseidon（意味的にはAx||AyをPoseidonで圧縮）。この値がMerkle木の葉となる。
4. Merkle検証：BinaryMerkleRoot(MAX_DEPTH)は
    - merkleProofLengthを用いて末尾の兄弟ハッシュを飛ばす最適化付き。
    - merkleProofIndex、merkleProofSiblingsから内部でビット展開→左右を選択してPoseidonで親ノードを再帰計算。
    - merkleRoot出力が回路外の公開入力と一致するか検証者がチェックする想定。
5. nullifier生成：
    - Poseidon(2)([scope, secret])。スコープ（例：投票ID）と秘密スカラーが一致しなければ nullifier が一致しないため二重投票検知が可能。
6. メッセージに対するダミー制約：dummySquare <== message * message
    - 実際の回路でmessageが使われないとGroth16で可換性攻撃（malleability）が発生し得るため、少なくとも一度制約にかける。
    - ただしdummySquareを公開する／公開入力に含めるわけではないので、検証者がmessage値を把握したい場合は別途ワイヤを公開とする必要がある。

- 5. チュートリアル

[チュートリアル](https://docs.semaphore.pse.dev/getting-started)

テンプレプロジェクト生成プロジェクト

```bash
npx @semaphore-protocol/cli create my-app --template monorepo-ethers
```

依存関係のインストール

```bash
cd my-app
yarn
```

テンプレアプリの構造

```bash
my-app
├── .yarn
├── apps
│   └── contracts
│   │   └── contracts
|   │   │   └── Feedback.sol
│   │   └── tasks
|   │   │   └── deploy.ts
│   │   └── test
|   │   │   └── Feedback.ts
│   │   └── hardhat.config.ts
│   │   └── package.json
│   │   └── tsconfig.json
│   └── web-app
├── .editorconfig
├── .env
├── .env.example
├── .eslintignore
├── .eslintrc.json
├── .gitignore
├── .prettierignore
├── .prettierrc.json
├── .yarnrc.yml
├── package.json
├── README.md
└── tsconfig.json
```

スマートコントラクトのコンパイル&テスト

```bash
cd apps/contracts
yarn compile
yarn test
```

Sepoliaへのデプロイ

```bash
yarn deploy --semaphore 0x8A1fd199516489B0Fb7153EB5f075cDAC83c693D --network sepolia
```

フロントエンドの起動

```bash
yarn dev
```

##### UniRep

Semaphoreプロトコルの上に構築された、匿名ユーザーデータと評判管理のためのゼロ知識プロトコルです。

- 1. 動機と機能：何のために作られ、何を実現しますか？
  - 動機
    - UniRepの基本的な動機は、ユーザーが自分のデータを完全に制御し、プライバシーを保護しながら、トラストレス（信頼不要）なオンラインでのやり取りを可能にすることです。
    - データ主権の回復：
      - Web2のアプリケーションでは、ユーザーがデータをプラットフォームに「貸し出している」状態にあり、データのハッキングや収益化のリスクがあります。
      - UniRepは、プラットフォームがユーザーのデータを保持しない**非カストディアル（Non-custodial）**なアプリケーションを促進し、データ漏洩のリスクを減らします。
    - 評判の拡張：
      - 従来の評判（レピュテーション）の概念を拡張し、好み、活動、連携、所有権など、ユーザーデータのさまざまな側面を含むように設計されています。
  - 機能
    - UniRepは、ゼロ知識技術を活用して、ZKアプリケーションのための強力なメモリ層として機能します。
    - 1. 匿名識別子によるデータ変更： 
      - UniRepは、時間と共に変化するエポックキー (Epoch Keys)短命な匿名識別子を使用します。
      - アプリケーション（アテスター）は、ユーザーのアイデンティティを知ることなく、このエポックキーを用いてユーザーデータを匿名で安全に変更することができます。
    - 2. 匿名での証明とデータの制御： 
      - ユーザーは、自分の情報に関する事実を証明し、結果を保存することができます。
      - データは公開されている場所に保存されますが、ユーザーの同意なしにデータが明らかにされたり、変更されたりすることはありません。
    - 3. 相互運用性： 
      - ユーザーデータは公開されているため、どのアプリケーションでもそのデータに基づいて証明を作成することができ、トラストレスな相互運用性が実現します。

- 2. ユースケース：非技術者にも説明できる実用例を挙げてください。
  - UniRepは、プライバシーが守られた環境で、ユーザーの過去の行動や属性を匿名で証明する必要がある、あらゆるアプリケーションの基盤となり得ます。
  - 匿名オンラインマーケットプレイス（Amazonのようなもの）： 
    - ユーザーは匿名で商品を購入し、購入履歴をプラットフォームに知られることなく安全に保存できます。
    - この購入履歴に基づいて、ユーザーのプライバシーを侵害することなく、クライアント側でおすすめ商品が計算されます。
  - 匿名信用スコア（P2P融資）： 
    - 従来の融資プロトコルが過剰担保に依存しているのに対し、UniRepではユーザーの評判データ（信用スコア）がレンディングプロトコルの規則遵守に基づいて変化します。
    - ユーザーは、具体的な過去のローン履歴を明かさずに、自分が信用に足る借り手であることを匿名で証明できます。
  - プライバシーを保護したメッセージング： 
    - ユーザーは、自分のEthereumアドレスを制御していることを一度だけ証明し、その証明をユーザーデータに保存することで、メッセージを送るたびに身元を明かすことなく匿名でグループチャットに参加できます。
  - 評判に基づく匿名アクセス： 
    - 匿名でGitHubにコードを公開したい開発者が、コミット数や成功したPR数などの評判指標をデータとして持ち、その評判を証明することで、身元を明かさずに特定のリポジトリへのプッシュアクセスを得ることができます。
  - 匿名ジャーナリズム： 
    - 特定のニュース組織に所属するジャーナリストが、報復を恐れることなく情報を公開する際、自分がその信頼できる組織の一員であることだけを証明し、ニュースの信頼性を高めながら、元のアイデンティティを隠すことができます。
  - 医療記録の相互運用性： 
    - 複数の病院（アテスター）が患者の医療記録を匿名でユーザーデータにアテステーション（証明）します。
    - ユーザーは、必要に応じてそのデータの所有権をzkProofで証明し、どの病院にも個人情報を渡すことなく、必要な情報へのアクセスを許可できます。

- 3. ハードル：採用に向けた課題や改善点は？
  - 1. 技術の複雑性と開発者体験の未熟さ：
    -  ゼロ知識証明技術自体が複雑であり、数学や暗号の背景がない人にとって理解が難しいという課題があります。
    -  UniRepを含むZK技術の開発者体験（Developer Experience, DX）はまだ非常に粗い（rough）状態にあり、実装が複雑で難しいことが、採用の最大の欠点（con）として挙げられています。
  - 2. プロトコルの完全性への依存：
    - プラットフォームがハッキングされるリスクからは保護されますが、ユーザーはプロトコル実装の欠陥や暗号技術自体の失敗に対して潜在的に脆弱になります。このため、ユーザーは偽りの安心感を持つ可能性があるという課題があります。
  - 3. データ変更（書き込み）の制約：
    - UniRepにおいて、ユーザーデータの変更（mutate）を行うには、ブロックチェーンへの**書き込みアクセス（トランザクション送信）**が必要です。
    - データの読み取りや証明（Read/Proof operations）はブロックチェーンの制約から独立してスケーリングできますが、書き込み操作はブロックチェーンの制限（例：1秒あたりのトランザクション数）の影響を受けます。
  - 4. 証明生成時間の課題：
    - 特定の証明（例：Ethereumアドレス所有権を証明するための初期のECDSA証明）の生成に約5分かかることがありましたが、これはユーザーデータに証明を保存する工夫により、後のメッセージ送信時の証明時間を約1秒に短縮する形で対応されています。

- 4. 回路の読み取り

回路は以下に格納

https://github.com/unirep/unirep/packages/circuits/circuits

https://deepwiki.com/unirep/unirep

```circom

```

- 5. チュートリアル

[チュートリアル](https://developer.unirep.io/docs/getting-started/create-unirep-app)

テンプレプロジェクト作成

```bash
npx create-unirep-app
```

ビルド

```bash
yarn build
```

ローカルブロックチェーン起動

```bash
yarn contracts hardhat node
```

ローカルブロックチェーンへデプロイ

```bash
yarn contracts deploy
```

Relayerサーバー起動

```bash
yarn relay start
```

フロントエンド起動

```bash
yarn frontend start
```

##### RLN

RLN（Rate-Limiting Nullifier）のによって開発されたzk-gadget/プロトコルです。

- 1. 動機と機能：何のために作られ、何を実現しますか？
  - 動機
    - RLNが開発された主要な動機は、匿名環境におけるスパムとDoS（サービス拒否）攻撃の防止です
    - スパム/Sybil攻撃への対抗：
      - 匿名性が高いアプリケーション（例：匿名チャット）では、ユーザーの身元がわからないため、誰でも無制限にスパムメッセージを送信したり、Sybil攻撃（一人のユーザーが多数の偽アカウントを作成する行為）を行ったりする可能性があります。
      - これにより、ユーザー体験やアプリケーション全体の機能が著しく低下するリスクがあります。
    - 抑止力：
      - RLNは、匿名性を保ちながら、システムとのやり取りの頻度（レート）を制限し、もしその制限を破った場合には**ペナルティ（罰則）**を課すことで、スパム行為に対する強い抑止力として機能します
  - 機能
    - RLNは、匿名性を維持しつつレート制限を実現するために、ゼロ知識証明と**Shamirの秘密分散法 (Shamir's Secret Sharing Scheme, SSS)**という主要な暗号概念を活用しています。
    - 1. レート制限の制御： 
      - RLNは、ユーザーが特定の時間枠内やイベント内（例：15秒間に1メッセージなど）で行うことができるアクションの数を制限します。
    - 2. 秘密の再構築によるスパム対策： 
      - ユーザーがメッセージ（シグナル）を送信する際、ZK証明と共にシークレットシェアと呼ばれる断片的な情報が公開されます。 
      - もしユーザーがレート制限に違反して規定以上のメッセージを送信した場合、十分な数のシークレットシェアが公開され、Shamirの秘密分散法によって元の秘密鍵（プライベートキー、またはアイデンティティコミットメント）が再構築されてしまいます。 
      - これにより、スパマーの正体を特定し、「キック」（システムからの追放やステークの没収）といったペナルティを課すことが可能になります。
    - 3. 匿名性の維持： 
      - RLNは、匿名性集合の一員であることを証明するためにSemaphoreの機能を活用しています。レート制限を遵守している限り、ユーザーのアイデンティティは匿名に保たれます。

- 2. ユースケース：非技術者にも説明できる実用例を挙げてください。
  - 匿名掲示板・チャットでのスパム対策：
    - Redditのような匿名掲示板や、Discordのような大規模な匿名グループチャットにおいて、「1つの投稿に対して1日にコメントできる回数を1回まで」のように制限します。これにより、誰かが悪意を持って大量のスパムメッセージを投稿してシステムを機能停止させる（DoS攻撃）のを防げます。
    - もし制限を破ってスパム行為を行った場合、その匿名ユーザーの身元が明らかになり、ペナルティ（例：デポジットした担保の没収）が課されます。
  - 匿名オークションの入札制限：
    - オークションシステムにおいて、特定のアイテムに対する入札数をユーザーごとに制限します。
    - これにより、一人のユーザーが多数の匿名アカウントを使ってオークションを不当に操作する行為を防ぐことができます。
  - 分散型・匿名型のDoS攻撃防止：
    - CloudflareのようなDoS攻撃対策システムを、匿名かつ分散型の方法で実現できます。
    - これにより、保護対象のサービスはユーザーの身元を知ることなく、攻撃者からのトラフィックを遮断できます。

- 3. ハードル：採用に向けた課題や改善点は？
  - 1. 技術的な複雑性：
    - RLNはゼロ知識証明（ZK-Proof）技術の一種であり、数学や暗号の知識がない人にとってはその仕組み（特にShamirの秘密分散法とZK証明の組み合わせ）が複雑で、実装や理解が難しいという課題があります。
  - 2. 証明生成時間とUX：
    - RLNのシグナリング部分はCircom回路で実装されており、一般にZK証明の生成には計算負荷がかかり、一定の処理時間を要します。これがユーザー体験（UX）に影響を与える可能性があります。
  - 3. 罰則システムの設計：
    - RLNの主要な機能は、違反者に対して秘密鍵を公開しペナルティを課すことにあります。
    - ペナルティとして担保（ステーク）を没収する場合、ユーザーはシステムを利用するために一定の経済的リスクを負う必要があり、これが新規ユーザーの参加ハードルとなる可能性があります。
  - 4. 開発環境の成熟度：
    - ZK技術の採用を拡大するには、シンプルで使いやすい開発ツールの提供や、技術的な概念をさらに抽象化することが求められます。
    - RLNについても、JavaScriptライブラリが提供されていますが、RustやPythonなどのライブラリも開発中であり、開発環境の成熟が求められます。

- 4. 回路の読み取り

回路は以下に格納されている

https://github.com/Rate-Limiting-Nullifier/circom-rln

https://deepwiki.com/Rate-Limiting-Nullifier/circom-rln

- 5. チュートリアル

## 2024年分の回答

## 2025年分の回答

## Deepwiki
- [ethereum/zket-core-program](https://deepwiki.com/ethereum/zket-core-program)
- [概要について解説を依頼した時のもの](https://deepwiki.com/search/_d4d98a83-02af-432b-8810-9933e7979378)
