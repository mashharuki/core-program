# メモ

## 2023年分の回答

### Week1

#### 概念の基礎

- ゼロ知識証明とは何か

  「正しい答えを知っている」ことだけを証明して、答えそのものは見せない高度な暗号技術。プライバシー保護や計算効率化などに役立つ

- 健全性、完全性、ゼロ知識性とは何か
  - 健全性
    - 嘘は、絶対に証明できない（見破られる）こと。
    - 嘘つきがシステムを悪用するのを防ぐ
  - 完全性
    - 正しいことは、必ず証明できること
    - 正直者が報われるようにする
  - ゼロ知識性
    - 証明されても、秘密の内容は相手に知られないこと
    - プライバシーを守ること

- 対話型と非対話型の証明の違いは何ですか？
  - 対話型
    - 証明したい人と検証者が何度もやり取りして証明が完了するタイプ
    - メリット
      - やり取りしながら調整でき、相手の質問に合わせて証明を柔軟に見せられる。
      - 途中で相手が納得しなければ追加の質問に答えて信頼を高められる。
    - デメリット
      - 何度も会話する必要があり、時間や通信がかかる。
      - 証明を保存して後で別の人に見せることが難しい。

  - 非対話型
    - 証明者から検証者に対して、たった一度だけメッセージ（証明、またはProof）を送れば、証明が完了するタイプ
    - メリット
      - 証明が1回のメッセージで済むので、送っておけばいつでも誰でも確認できる。
      - ブロックチェーンのように多くの人が同じ証明をチェックしたい場面で便利。
    - デメリット
      - 一度作った証明が間違っていたらやり直すのが大変。
      - 成り立たせるために特別な仕組み（例：共通の「ランダムな設定」やハッシュ関数の利用）が必要で、条件が多くなる。

- ウォーリーを探せはわかりやすい
  - どこにウォーリーがいるかは伝えたくない。でも見つけたことがだけを共有したい。
  - この応用としてパスワードとかをサーバー側に直接伝えることなく、認証サービスを作るときなどに役立ちそう(まさにこれってSuiのzkLogin)

- もっとも興味深い応用例
  - ZK Rollup
    - プライバシー保護のために生まれたアイディアを計算効率化に応用しているのがまず面白い。
    - ZKの本質的な部分は **プライバシーの保護と計算効率化(スケーラビリティの向上)** に使える技術だということが理解できた。

- 他の応用例
  - 将来的に人の意識を交換するような技術が実現すると考えられている。重要なプライバシーデータを秘匿化しつつ、純粋に記憶力や論理的思考力のみをレンタルできるようにしても良いかもしれない。

#### 数学の基礎知識

- 基礎：
  - 素数・合成数

    素数と合成数は、1より大きい自然数を、その約数（割り切れる数）の数によって分類したもの。

    - 素数 
      - 1と自分自身でしか割り切れない自然数。
      - 例：2, 3, 5, 7, 11…。
    - 合成数 
      - 1と自分以外にも割れる相手がいる自然数。
      - 例： 4（2×2）、6（2×3）、9（3×3）など。

  - 最大公約数（GCD）

    2つ以上の整数に共通する約数（割り切れる数）の中で、最も大きい数のこと

- モジュラー算術と合同：
  - モジュラー算術とは？
    - 割り算の余りに注目した特殊な計算方法のこと。
    - 「○で割った余りだけを考える計算」。12で割った余りを考えるなら、14も26も38も全部「2時」と同じです。これがモジュラー算術の基本的な考え方。
    - 「ぐるぐる時計算」と考えるとわかりやすいです。たとえば12時間の時計では、10時に4時間進むと14時ではなく2時になりますよね。この「12で一周して同じ位置に戻
  る」ルールを使う計算がモジュラー算術です。

  - 合同類の考え方
    - モジュラー算術において、同じ数を法として割ったときに同じ余りになる整数のグループのこと。
    - 12時間の時計で考えると、2時・14時・26時は全部「2時と同じ場所」なので同じ箱に入ります。この「同じあまりの数字を集めた箱」が合同類です。
    - 例：法5の合同類
      - 余りが0になる数の合同類
      - このグループには、5で割り切れるすべての整数が含まれます。
      - ..., -10, -5, 0, 5, 10, 15, ...

- 群論：
  - 群構造:
    - ある集合に演算が定義され、いくつかの満たすべき公理（ルール）が定められているときの、その集合と演算が持つ「性質」や「骨組み」のこと
    - 群構造を持つことで、その集合の中の要素を「足したり」「かけたり」するような操作ができるようになり、その操作には特定の決まりがある、ということ
    - 群構造の3つの公理
      - 結合法則
        - 3つ以上の要素を演算する場合、どの2つを先に演算しても結果は同じになります。
        - 例：\((A\cdot B)\cdot C=A\cdot (B\cdot C)\)
      - 単位元の存在
        - ある特定の要素（単位元）をどの要素に演算しても、その要素自体は変化しません。
        - 例：\(A\cdot E=E\cdot A=A\)（\(E\)が単位元）
      - 逆元の存在
        - どの要素にも、演算すると単位元になるような要素（逆元）が必ず存在します。
        - 例：\(A\cdot A^{-1}=A^{-1}\cdot A=E\)（\(A^{-1}\)が\(A\)の逆元）
    - 例：
      - 「整数の足し算」
      - この場合の集合は整数、演算にあたるのは足し算
    - 群構造は、数学のさまざまな分野で現れる基本的な骨組みです。この構造を理解することで、一見異なる分野（例えば、幾何学と物理学）に共通する性質や法則を見つけることができます。
    
  - 群演算:
    - ある特別なルールを持った、集合の中の2つの要素を組み合わせて新しい要素を生み出す操作のこと
    - 「群構造」を成立させるために必要な「演算」が、この「群演算」にあたる
    - 最も身近な例は、整数の足し算です。この場合の「群演算」は足し算です。

- さらに深く：
  - 有限群： 
    - 要素の数が有限である群のこと。
    - 例：正方形の対称性の群
      - 集合: 正方形を動かす8つの操作（回転と反転）の集まり。
        - 0度、90度、180度、270度の回転
        - 垂直、水平、2本の対角線に沿った反転
      - 演算: 操作を連続して行うこと。
        - たとえば、「90度回転」のあとに「水平反転」を行う、といった操作です。
      - ルール: これらの操作はすべて群演算の4つのルールを満たします。
      - 閉鎖性: どの操作を組み合わせても、結果は8つのうちのどれかの操作になります。
      - 単位元: 「0度回転（何もしない）」という操作が単位元になります。
  - 巡回群：
      - たった1つの要素を繰り返し演算するだけで、すべての要素を作り出すことができる群のこと
  - 生成元：
      - 生成元とは、特定の代数構造（群など）において、繰り返し演算を行うことで、その構造全体のすべての要素を作り出すことができる特別な要素のこと
      - 生成元は、その構造を「生み出す種」のようなもの
      - 例：時計の文字盤

        この例では、「1時間進める」という操作（生成元）を繰り返すことで、時計のすべての数字（要素）を作り出すことができます。
        - 集合: \(\{12,1,2,...,11\}\) の12個の数字
        - 演算: 1時間を進める操作
        - 生成元: 「1時間」という操作
          - 「1時間」を1回 → 1時
          - 「1時間」を2回 → 2時
  - 有限体：
      - 有限体とは、要素の数が有限でありながら、四則演算（足し算、引き算、掛け算、割り算）が自由にできる集合のこと。有限体はガロア体（Galois Field）とも呼ばれ、GFと記載されることが多い。有限体は、要素の数が有限であるため、コンピューターで扱うのに非常に適している。そのため、暗号技術や通信エラー訂正など、情報科学の分野で広く応用されています。
        - 四則演算ができる: 集合の任意の2つの要素を足したり引いたりかけたり割ったりしても、その結果が必ず元の集合の中に戻るという性質（閉鎖性）を持ちます。
        - 割り算のルール: ただし、0で割ることはできません。
        - 例
          - 3を法とする有限体（GF(3)）
          - 集合: \(\{0,1,2\}\)
          - 足し算（mod 3）: 
            - \(1+2=3\) なので、余りは \(0\)
          - 掛け算（mod 3）:
            - \(1\times 2=2\)
            - \(2\times 2=4\) なので、余りは \(1\)
          - 割り算（mod 3）:
            - \(1\div 2\) は、**\(2\times x=1\)（mod 3）**となる \(x\) を探します。上記の掛け算から、\(x=2\) です。

#### 演習

#### 理解度チェック

1. 帽子の三色塗り分け問題（グラフ三色問題）

    - 複数の人が輪になって座り、互いの帽子は見えますが、自分の帽子の色は見えないという状況で、自分の帽子の色を推測するというもの
    - 絵で描くと、人を丸で、隣同士を線で結んだ図（グラフ）になるから「グラフ三色問題」と呼ぶんだ。
    - みんなで話し合って順番に色を決めたり、３色が足りないと気付いたら最初からやり直したりして、ルールを守る塗り方を探す遊びなんだよ。

2. アリババの洞窟のたとえ話

  - 2つの通路と魔法の扉。秘密の合言葉を知る証明者(ペギー)は、検証者(ビクター)が指示した側の通路から出てくることで「言葉を知っている」ことを示すが、言葉自体は明かさない。繰り返しで信頼度を高める対話型の証明。

3. 対話型と非対話型の証明の違い
  - 対話型は証明者と検証者が何度もやりとりして証明が正しいことを検証する方法。
  - 非対話型は証明者と検証者が1回のやりとりで証明が正しいことを検証する方法。

#### モジュラー演算

- 1. 7 mod 13. 
  A: 7
  
- 2. 15 mod 13. 
  A:2

- 3. (7 + 15) mod 13. 
  A: 9

- 4. (7 mod 13 + 15 mod 13) mod 13. 
  A: 9

#### 生成元

巡回群 (Z_{12}, + mod 12)（12を法とする加法群）について：

- 1. 生成元とは何ですか？

  A: 特定の代数構造（群など）において、繰り返し演算を行うことで、その構造全体のすべての要素を作り出すことができる特別な要素のこと

- 2. この群の生成元を一つ挙げてください。

  A: 1 (1を足し引きすることで0~11を全て生成できるから)

- 3. 他にも生成元はありますか？あれば挙げてください。  

  A: 5,7,11(それぞれ使って足し引きすることで0〜11の全ての要素を生成できる。)

#### 加算・減算・乗算をサポートする簡単なモジュラー計算機を作成する

関数 `modularCalculator` は次の4引数を取ります：
- 文字列 `op`（演算子: '+', '-', '*' のいずれか）
- 整数 `num1`, `num2`（オペランド）
- 整数 `mod`（法）

計算結果に対して mod を取った値を返してください。  
減算で負になることがある点に注意し、必要に応じて `mod` を足して正にしてください。

結果

```js
function modularCalculator(op, num1, num2, mod) {
    let result = 0;
    switch (op) {
        case '+':
          // 足し算して法で割る
          result = (num1 + num2) % mod;
          break;
        case '-':
          // 引き算して法で割る
          result = (num1 - num2) % mod;
          // 正の数に補正sルウ
          if (result < 0) result += mod;
          break;
        case '*':
          // 掛け算して法で割る
          result = (num1 * num2) % mod;
          break;
        default:
          return "Invalid operation";
    }
    return result;
}

modularCalculator('+', 10, 15, 12); // 1
modularCalculator('-', 10, 15, 12); // 7
modularCalculator('*', 10, 15, 12); // 6
```

### Week2

- 対称鍵と非対称鍵の主な違いは？

  鍵の数が1本か2本か

- AES の動作概要

  - AES（Advanced Encryption Standard）はNISTが2001年に採用した共通鍵ブロック暗号で、128ビットのブロックを扱い鍵長は128/192/256ビットに対応します。
  - 内部では128ビットのデータを8ビット×16個の4×4行列（Stateと呼ぶ）に並べ替え、各ラウンドで代入・並べ替え・行列演算・鍵加算を繰り返すことで拡散と混同を実現します。
  - まずState表現に慣れましょう。平文128ビットを列優先で4列×4行に詰めると、各操作が視覚化しやすくなります。
  - 主要ステップを順に把握します：SubBytesは非線形S-box代入で混同を導入、ShiftRowsは行ごとに循環シフトして列間の依存を広げ、MixColumnsはGF(2⁸)多項式演算で列内のビットを混ぜ、AddRoundKeyはラウンド鍵とのXORで鍵依存性を注入します。最後のラウンドのみMixColumnsを省略します。
  - 鍵スケジュールは初期鍵をワード（32ビット）単位で展開し、RotWord・SubWord・ラウンド定数（Rcon）を使って各ラウンド鍵を生成する仕組みです。鍵長ごとに展開ルールが少しずつ変わるので、図を描きながら追うと理解が進みます。
  - AES自体はブロック暗号なので、実際の通信ではCBCやGCMなどの運用モードで連結します。この段階では「AES本体は固定長ブロック＋鍵で決まる置換」「モードがブロックの連携方法を定義する」と切り分けて覚えると混乱しません。
  - 4×4行列に平文を詰め、1回分のSubBytesとShiftRowsを手計算してStateの変化を確認する。
  - 小さなスクリプト（例：Node.jsのcryptoではなく自作）でS-box代入とMixColumnsの実装を行い、公式テストベクトル（AES-128のKnown Answer Test）で1ラウンドの出力を
  照合する。
  - 鍵スケジュールを紙に展開してRconの使い方を整理し、128/256ビット鍵でどこが異なるかをまとめる。


- RSAが広く使われている理由

  - RSAは1977年の提案以降、最初期に公開された公開鍵暗号であり、暗号化と署名の両方を一つの枠組みで実装できる点が評価されました。
  - 1980〜90年代にかけて標準化団体（PKCS、X.509、TLS、PGPなど）が次々に採用した結果、ほぼすべてのOS・ブラウザ・ハードウェアがデフォルトでサポートする状態が築かれました。

  - 成熟した安全性モデル：安全性が大整数の素因数分解困難性に帰着し、学術的解析が豊富。鍵長を伸ばすだけで耐性を調整しやすい。
  - 標準化と相互運用性：PKCS#1、TLS、S/MIME、OpenPGPなどの標準仕様がRSAを前提に整備され、異なる実装同士でも動作保証が容易。
  - 実装資産とハードウェア支援：長年にわたり最適化されたライブラリやHSM、スマートカード、TPMなどのハードウェアがRSAをネイティブサポート。既存インフラを維持するコストが低い。
  - 鍵配送の課題解決：対称鍵暗号の鍵共有問題を解消し、ハイブリッド暗号（RSAでセッション鍵を暗号化→AES等で本体通信）を可能にした。
  - 用途の広さ：暗号化とデジタル署名を同一数学的構造でカバーし、PKIの基盤として企業・行政システムに実装しやすかった。
  - 歴史的先行者利益：ECCや他方式が成熟する以前から普及しており、新興方式より互換性・保守性が重視された。

- 離散対数問題（DLP）とは？

  - ある巡回群における離散対数（指数）を求める問題のこと
  - 通常の対数では簡単に計算できる逆算が、特定の群（有限体など）では非常に難しい（計算量的困難性がある）という性質を利用しており、現代の暗号技術の基盤となっている。

- Diffie–Hellman はどう動作しますか？
  - 盗聴される可能性がある通信路（インターネットなど）を使って、2人だけで共通の「秘密の鍵」を作り出すための仕組み。
  - Diffie–Hellman鍵共有は、1976年に提案された「離散対数問題の難しさ」を使った仕組みで、第三者に知られずに共通鍵を作る方法です。暗号化に必要な鍵を、安全な通信路がなくてもオンラインで合意できます。
  -  1. 共有準備：大きな素数 p と「元（Generator）g」を公開。誰でも見られる。
  - 2. 秘密選択：アリスは秘密数 a、ボブは秘密数 b を選ぶ。これは他人に教えない。
  - 3. 送信：アリスは A = g^a mod p を計算してボブに送る。ボブも B = g^b mod p を計算してアリスに送る。A と B は公開されても構わない。
  - 4. 共通鍵生成：アリスは K = B^a mod p、ボブは K = A^b mod p を計算。実は両者の結果は g^(ab) mod p で同じ値になる。
  - 5. 安全性：第三者が A と B、p、g を知っていても、a や b（ひいては K）を求めるには離散対数問題を解く必要があり、現実的な時間では困難とされる。

- ElGamal の要点は？
  - エルガマル暗号は、ディフィー・ヘルマン鍵交換の仕組みを応用した公開鍵暗号方式です。
  - 離散対数問題の計算困難性を安全性の根拠としており、暗号化と復号に非対称な鍵ペア（公開鍵と秘密鍵）を使用します。

- DLP 系の弱点（欠点）を1つ挙げてください。
  - サブ指数時間アルゴリズム：有限体 DLP は指数より速いアルゴリズム（例：Number Field Sieve, Function Field Sieve）が存在するため、十分大きな素数でも安全余裕が削られます。結果として RSA と同様に巨大なパラメータが必要。
  - 構造を悪用した攻撃：特殊な素数や小さなサブグループを使うと、Pohlig–Hellman や小サブグループ攻撃で計算が大幅に楽になります。パラメータ選定の自由度が狭い。
  - 計算コスト：大きな有限体上での指数演算は重く、鍵交換・署名検証が ECC や現代的 SNARK 向けプリミティブより遅くなる傾向。
  - 量子耐性がない：大きな量子コンピュータが実現すると Shor アルゴリズムで DLP が多項式時間で解けるため、根本的な破り方が存在。
  - サイドチャネル耐性：指数演算を長時間行うため、タイミング・電力解析などのサイドチャネル攻撃面の露出が広い。

- デジタル署名の役割と重要性は？
  - デジタル署名は「このデータは確かに私が作りました」「途中で書き換えられていません」を証明する仕組みのこと。
  - 受け取った人は公開鍵で署名をチェックするだけで、送信者の本人確認（認証）と内容の改ざん検知（完全性）を同時に行えます。
  - これによりインターネットバンキングやソフトウェア配布、電子契約などを安心して利用でき、送信者が「送っていない」と後から言い逃れできない（否認防止）点も重要です。

- DSA の仕組みを説明してください。
  - DSA（Digital Signature Algorithm）は米国政府が標準化したデジタル署名の方式で、離散対数問題（Diffie–Hellman 系と同じ難しさ）を使って安全性を確保します。
  -  1. 公開の土台を決める：
    - 大きな素数 p と、その中でよい性質を持つ生成元 g を選びます。
    - さらに q という p-1 を割る小さめの素数も決めます。これらは誰が見てもOKな公開情報です。
  - 2. 鍵の準備：
    - 利用者は q 未満の数字 x を秘密鍵として選びます。
    - 公開鍵は y = g^x mod p。x（秘密鍵）を知られてはいけません。
  - 3. 署名の計算：メッセージ M を送るとき、送信者はハッシュ値 H(M) を計算し、ランダムな数 k（毎回新しく）で
      - r = (g^k mod p) mod q
      - s = (k^{-1} · (H(M) + x·r)) mod q
      - という手順で署名 (r, s) を作ります。k を使い回すと秘密鍵が漏れるので要注意。
  - 4. 検証：受信者は公開鍵 y を使って (r, s) が正しいか確かめます。
      - w = s^{-1} mod q、u1 = H(M)·w mod q、u2 = r·w mod q
      - v = ((g^u1 · y^u2) mod p) mod q
      - v が r と一致すれば署名は正しい（＝送り主が秘密鍵で署名した・途中で改ざんされていない）と判断できます。

#### 演習

1. 対称鍵 vs 非対称鍵の違いと、それぞれの実用例。

- 対称鍵暗号：暗号化・復号に同一の鍵を利用する。高速・単純だが鍵配送が課題。
  - 例：信頼できるチャネル内でのデータ送信。
- 非対称鍵暗号：公開鍵で暗号化、秘密鍵で復号する。鍵共有は容易だが計算コストが高い。
  - 例：PGP メール。受信者の公開鍵で暗号化し、受信者だけが復号。

2. Diffie–Hellman を用いたメッセージングの安全性向上の仕組み。

 - Diffie–Hellman は安全でないネットワーク上で共有秘密を合意できる。
 - 実運用ではメッセージングのエンドツーエンド暗号化の基盤となる。

3. SHA-256 と Poseidon の特徴と、Poseidon の利点を1つ。

- SHA-256 は衝突・原像攻撃への耐性と速度のバランスが良い。
- Poseidon は回路に親和的な設計で ZKP に適する。

4. メルクル木が大規模データ検証を効率化する理由。

- 葉〜根の経路ハッシュのみで**包含検証**ができるため、大規模データでも効率的に検証可能。
- ZK Rollupなどブロックチェーンのトランザクション検証に使われる。

5. Pedersen コミットメントがトランザクションのプライバシーを保つ方法。

- Pedersen は値を隠しつつ後で開示可能（ハイディング＆バインディング）。
- 機密送金で金額を伏せる用途など。

6. デジタル署名付き文書の真正性確認の方法。

- 署名者の公開鍵で検証する。検証成功は「対応する秘密鍵所持者が署名し、メッセージが改ざんされていない」ことを示す。

### Week3

### 演習

#### 楕円曲線入門

1. 楕円曲線の一般式は？

- 「Weierstrass（ワイエルシュトラス）形式」と呼ばれる次の形で表せます
-  y² + a₁xy + a₃y = x³ + a₂x² + a₄x + a₆
  - a₁, a₂, a₃, a₄, a₆ は係数で、曲線の形を決める値です。
- 実際の暗号では扱いやすいように、係数を変換して簡略化した「短縮版（short Weierstrass form）」を使うことが多く、
  - **y² = x³ + ax + b**
  - と書かれる。このとき判別式 Δ = -16(4a³ + 27b²) が 0 でないことが楕円曲線として成り立つ条件です。

2. 2点 P, Q の和 P+Q はどのように求めますか？

- 楕円曲線（短縮ワイエルシュトラス形 y² = x³ + ax + b）では、点同士の加法は「線を引いて反転させる」操作として定義されています。
- 具体的には、P と Q を通る直線を引いて曲線と交わる3つ目の点 R を探し、その点を x 軸で鏡映した点がP+Q になります（R の x 座標は同じで、y 座標に符号を付け替える）。

3. 加法における単位元は？

- 足し算の単位元は「足しても相手が全く変わらない数」のことです。
- ふつうの整数なら 0 がそれに当たり、5 + 0 = 5 のように元の数がそのまま残ります。
- 楕円曲線の点の足し算でも同じ考えで、特別な **「無限遠点 0」** を単位元とし、どんな点に足しても結果がその点自身になります。

#### ECC

1. ECC が RSA 等に対して持つ主な利点は？

- ECC (Elliptic Curve Cryptography/楕円曲線暗号) と RSA はどちらも公開鍵暗号だが、同等の安全性を達成するために必要な数学的難易度が異なる。
  - RSA は**大きな素数の積の分解困難性に依存する**
  - ECC は**楕円曲線離散対数問題の困難性に依存する**

- 1) キーサイズの短さ（ECC 256bit ≒ RSA 3072bit）→ 処理効率とメモリ削減
- 2) 同じセキュリティをより低い計算量・電力で実現でき IoT/- モバイルに適切
- 3) 証明書や署名のサイズ縮小で通信帯域を節約でき
- 4) 離散対数問題は既知のアルゴリズムでは大規模並列化しにくく量子以前でも優位性が高い
- 5) ECDH/ECDSA など複合プロトコルで鍵交換と署名を柔軟に設計できる点。

- 同等安全性で短い鍵長。計算・帯域・ストレージが軽い。

2. ECC の公開鍵はどのように秘密鍵から導出しますか？

- ECCの公開鍵生成は、有限体上の楕円曲線 E(F_p)、生成元 G、その位数 n というドメインパラメータが前提です。
- 秘密鍵 d (スカラー、整数) を乱数から選び、楕円曲線上での点の加法・倍算を用いて Q = d·G を計算することで公開鍵が得られます。

3. ECDLP とは？

ECDLP（Elliptic Curve Discrete Logarithm Problem／楕円曲線離散対数問題）は、楕円曲線暗号（ECC）が安全と考えられる根拠となる難問です。

有限体上の楕円曲線E(F_p) と生成元 G を用いて、秘密鍵 d を掛け合わせた点 Q = d·G から d を逆算することが ECDLP で、既知の効率的アルゴリズムが存在しません。RSA の素因数分解問題に相当する役割を果たします。  
⇨ Q と dG から dを求める(逆算する)ことが困難なこと

#### Schnorr と EdDSA

1. Schnorr 署名の利点は？

- シンプルな数式: s = k + e·x の1本で成立し、逆変換も容易なため実装・検証がしやすい。
- マルチシグ/アグリゲーション適性: MuSig2などのプロトコルで、複数人の署名を一回にまとめられ、ビットコインTaprootやZKプロジェクトで採用が進む。
- シンプル・効率的・線形性により集約が可能(マルチシグ集約が可能)。

2. EdDSA は従来の Schnorr と何が異なりますか？

- EdDSA（Edwards-curve Digital Signature Algorithm）は、Schnorr署名のアイデアをそのままに、Twisted Edwards曲線とハッシュ駆動の決定的ノンス生成、定められたエンコード規則でフォーマライズした“実用仕様”です。
- Ed25519/Ed448が代表例で、Schnorrとの差は主にどの曲線・乱数生成・エンコードを採用するかにあります。
- ねじれ Edwards 曲線を用い、乱数が決定的（鍵とメッセージから導出）。

#### ペアリングベース暗号

1. 楕円曲線暗号におけるペアリングとは？

- ペアリング（双線形写像）は、楕円曲線上の2つの点群 G1, G2 を別の有限体乗法群 GT に写す仕組みで、e(P + P', Q) = e(P, Q) · e(P', Q) のような線形性（双線形性）を持ちます。
- ECCそのものはペアリングを使わずとも成立しますが、この双線形を活かすことで BLS署名やzkSNARK（例: Groth16）、IDベース暗号など高度なプロトコルが実現できます。

  - 「点の足し算が、別の世界では掛け算に変身するスイッチ」とイメージします。e(P+P', Q) = e(P, Q) × e(P', Q) という形で、足し算が掛け算に変わるのがポイントです。
  - このスイッチを使うと、みんなの署名をひとまとめにしたり（マルチシグ）、証明をコンパクトにしたりできます。だからSNARKやBLS署名で大活躍するのです。

2. 双線形写像の3つの性質は？

- 双線形性: 片方の入力を足すと結果が掛け算に分配される性質（例: e(P+P', Q) = e(P, Q)·e(P', Q)）。これがあるので計算をまとめたり並べ替えたりできる。
- 非退化性: 特別な点（単位元）以外を入れると結果がつねに1以外になる性質。これで「意味のある情報」が失われず、証明や署名が壊れない。
- 効率的可算性: 実際に計算できること。Millerループや最終冪乗といったアルゴリズムで現実的な時間内に値を求められるから、プロトコルとして実装可能になる。

3. ペアリングで可能になる応用を1つ挙げてください。

- 複数の署名や証明を一度にまとめて検証できるようになる点がポイント。
- BLS署名が可能になる
  - 各参加者が同じメッセージへ署名しても、ペアリングのおかげで **署名を全部足し合わせた1本の署名 σ_total** にでき、検証側も e(σ_total, G) と **e(H(m), 公開鍵の合計) の2回だけでチェック可能** です。 **従来方式のように署名本数分の検証をする必要がなく**、ブロックチェーンのように大量署名が発生する場面で通信量と計算量を大幅に抑えられます。

#### KZG 多項式コミットメント

1. 多項式コミットメントの目的は？

- 多項式コミットメントは「ある多項式を作りました」と宣言（コミット）し、そのあとで「この多項式に特定の値を入れると結果はこうです」と証明できる仕組みです。
- 肝は「多項式そのものは渡さなくても、決めた結果が本物だとみんなが確かめられる」こと。
  - 例：「秘密のレシピ（多項式）から、特定の材料（入力）で作った料理（出力）が正しい」と他人に示せます。

- コミットメントは「封筒」。多項式を封筒に入れて封をし、中身を変えられないようにします（束縛性）。
- 評価証明は「この封筒の中身に材料xを入れるとyができます」という説明書。見る人は封筒を開けずに、説明書が正しいかチェックできます（完全性）。
- zkSNARKやPLONKでは、この仕組みがあるから大量の計算結果を小さな証明で共有できる。入力を変えずに証明だけで安全に伝えられる。

2. KZG で多項式と秘密値に対するコミットはどう計算しますか？

- 1. 多項式の準備: たとえば f(x)=a₀+a₁x+a₂x² の係数 (a₀,a₁,a₂) を決めます。
- 2. コミット計算: SRSに含まれる点 G, G^{τ}, G^{τ²} を係数で重み付けして足し合わせ、C = a₀·G + a₁·G^{τ} + a₂·G^{τ²} を計算します。これが多項式へのコミットで、封筒に相当します。
- 3. 秘密値（評価）の扱い: 例えば z に対して y = f(z) を主張したいときは、f(x) - y を (x - z) で割った商 q(x) を求め、同じSRSで W = Σ q_i · G^{τ^i} を計算します。これが証明（witness）です。
- 4. 検証: 誰でも e(C - y·G, H) と e(W, H^{τ - z})（別側のSRS点を使う）を比較して一致するかチェックでき、正しい評価なら成立します。実際にはペアリングを1回で済むよう整理されています。
- 5. 直感: コミット C は係数を書き換えると成立しなくなるので束縛性、W と y をセットで出さないと検証に通らないので完全性が確保されます。

もっと簡単に説明したバージョン

-  KZGコミットメントは「ひみつの算数（多項式）ノート」を封筒に入れて見せずにしまい、あとで「このページの問題に 3 を入れたら答えは 5 だよ！」と証明できる魔法の仕組みです。みんなは封筒の中を見なくても、その答えが本当かチェックできます。

- ひみつノートを書く: 多項式 f(x) を、たとえば f(x)=2+x みたいに係数で決めておく。
- 魔法の封筒を作る: セットアップでもらった「不思議な鍵（SRS）」を使い、係数と鍵を組み合わせて封筒 C を作る。ここにノートの中身がこっそり隠れる。
- 答えを先に計算: z=3 をノートに入れて計算すると y=5 が出る。この y をメモしておく。
- 正しいよという証明書を作る: f(x) - y を (x - z) で割ったときの商 q(x) を使って、もう一度 SRS を組み合わせ、証明書 W を作る。
- みんながチェック: 見る人は封筒 C・答え y・証明書 W を受け取り、同じSRSで「計算がほんとに合っているか」を計算。合っていれば「このノートに 3 を入れると必ず 5 になるんだ！」と信じてくれる。

3. KZG が効率的・簡潔とされる理由は？

KZG多項式コミットメントは.**「多項式を小さな封筒1つにまとめ、評価の正しさもたった1回のペアリング検証で確かめられる」**  d点が強みです。

「効率的・簡潔」と言われる理由は大きく以下の3つです。

- 証明サイズが常に一定: 多項式の次数に関係なくコミット（封筒）も評価証明も1つの曲線点で済み、通信量が O(1)。大きな計算でもデータが小さいまま。
- 検証がペアリング1回: 検証者はペアリング評価をほぼ1回するだけで正当性をチェックできる（実装によっては2回→まとめて1回に最適化）。これが Groth16 などの高速SNARKの背骨。
- シンプルな算術: 証明者は一度多項式を (x - z) で割って係数を SRS 点と掛けるだけ。複雑なFFTや追加の多段階手続きが不要で、実装やZK回路に組み込みやすい。

#### Trusted Setup

1. なぜ Trusted Setup は重要ですか？

trusted Setup（トラステッド・セットアップ）は、zkSNARKやKZGのような一部の暗号プロトコルを動かすために最初に行う特別な準備作業です。ここで作られた「共通の鍵（CRS/SRS）」をみんなが使うことで、あとの証明や検証がとても小さく速くなります。

ただし、この準備の途中で出てくる「毒性廃棄物（toxic waste）」と呼ばれる秘密情報が外に漏れると、悪い人がウソの証明を作れてしまうため、参加者みんながこのセットアップ手順を正しく行い、残った秘密を必ず破棄したと信頼できることが重要です。

2. zk-SNARK と Trusted Setup の関係は？

zk-SNARK は「とても小さな証明で巨大な計算をチェックできる」仕組みですが、その効率を得るために多くの方式（例: Groth16, PLONK, KZGベース）は最初に TrustedSetup と呼ばれる準備で共通鍵（SRS/CRS）を作ります。
 
この準備中に生まれる秘密パラメータ（毒性廃棄物）が完全に破棄されていれば、以後は高速・小サイズな証明を安心して使えます。反対に、誰かがその秘密をこっそり保持すると偽造証明を作れるため、セットアップ手順を信頼できることが zk-SNARK の安全性に直結します。

- 共有参照文字列（CRS）に依存。安全な生成・破棄が前提。
- 従来のPKIのキーセレモニーと全く同じ課題。鍵のライフサイクルの運用が肝。

3. Trusted Setup の課題は？

- 信頼性・透明性・分散化・運用コスト。

- 全員が正直だったと信じる必要がある：セレモニー中の秘密（毒性廃棄物）が誰かの手に残ると、偽の証明を作れてしまう。
- 大掛かりな準備が必要：多人数でのセレモニー、録画、監査、専用機材など手間とコストが高い。
- セットアップ失敗の検出が難しい：あとから「実は秘密を捨てていませんでした」と証明する術がほぼなく、一度疑いが生じると信頼回復が困難。
- プロトコルごとにやり直しが発生：回路専用セットアップでは、回路を変えるたびに再度セレモニーが必要になり、開発スピードを落とす。

### Weel4

#### 準同型隠蔽（Homomorphic Hiding）

1. 自分の言葉で説明：

- 「値を隠したまま、外から演算（足し算や掛け算の一部）ができる」仕組みのこと。
- 開示後の結果が平文演算と一致するような仕組み

- 準同型性：封筒の外で「加算（あるいは乗算）」など決められた演算をすると、中の秘密値にも同じ演算が反映されます。Pedersenコミットメントは足し算に対応する代表例。

---

#### 算術回路

そもそも算術回路とは？

プログラムの動きを「足し算・掛け算だけができる電気回路」のように表現したもの。

入力から出力までの計算手順を秩序立てて並べ、各ステップが有限体上の方程式として成り立つように設計する。

1. 算術回路に変換する目的：
   
- 「プログラムの実行の正しさ」「特定の多項式が条件を満たすか」数学的な検証問題に変換するため
- 複雑な計算を加算・乗算ゲートのネットワークに平坦化し、R1CS など次段の表現に移しやすくするため。

2. 主な構成要素：
   
算術回路そのものや、それが変換される制約システムは、主にゲートと制約によって構成されます。

- ゲート・ワイヤ・入出力ポート

- 1. ゲート/基本的な演算（Gates / Operations）
  - 算術回路の構成要素は、計算のロジックを表現する基本的な数学的操作（ゲート）です。
    - 算術回路は、あらゆる計算やプログラムのロジックを、加算（+） と 乗算（×） のような基本的な数学的操作の組み合わせとして表現します。
    - 初期のシステム（例：Groth16など）では、算術回路は主に加算と乗算の基本演算のみで構成されていました。これは、複雑な計算を表現するために多くの基本演算を組み合わせる必要があり、非効率的でした。
    - 最近の進展では、PLONKのような新しいプロトコルでは、カスタムゲートが導入されました。これにより、通常の加算/乗算以外のより複雑な演算（例：ビット演算、条件分岐、ルックアップテーブル、より複雑な数学的関数）を直接1つのゲートとして定義できるようになっています。
- 2. 制約システム（Constraint System）
  - 算術回路は、多くの場合、証明システムが検証しやすい代数的な制約のセットに変換されます。
    - zk-SNARKsの算術化（Arithmetization）は、**制約のセット（set of constraints）**として表現されることが一般的です。
    - 最も一般的に使用される制約システムの一つが、**R1CS（Rank 1 Constraint System）**です。
      - R1CSでは、すべての計算が「（A）$\times$（B）＝（C）」という形式の制約のセットとして表現されます。
      - ここで、A、B、Cは、回路の入力値、中間値、出力値などの変数の線形結合です。
    - このR1CS形式は、さらに **QAP（Quadratic Arithmetic Program）** と呼ばれる多項式のセットに変換されます。Pinocchio（最初の実用的なzk-SNARK）もこのQAPに基づいていました。
  - Circomのような回路記述言語では、プログラムが必ず「$A \times B + C = 0$」の線形結合の制約となるように記述されます。
- 3. ワイヤー値（Wire Values）/ 変数
  - 回路を流れる中間的な計算結果や、入力・出力される値も構成要素です。
    - 回路内の演算（ゲート）は、入力された値（変数）に対して実行されます。証明者（Prover）は、秘密の値である**ウィットネス（$w$）**を知っていることを証明します。検証者（Verifier）は、このウィットネスを用いて計算された関数$\mathcal{F}$の結果が、公開された出力$y$と等しいこと、すなわち$\mathcal{F}(x; w) = y$であることを証明を通して確認します。
    - VOLEベースのZKPでは、IT-MACsが、計算を表す算術回路またはブール回路内の**認証されたワイヤー値（authenticated wire values）**へのコミットメントとして使用されます。

- 算術化（Arithmetization）のプロセス
  - 算術回路は、ZKPプロトコルで検証できるように、計算全体を代数的な形に変換する算術化プロセスの中核を担います。
    - 1. 高水準言語で書かれた計算ロジック（プログラム）を、CircomのようなZK DSL（ドメイン固有言語）やライブラリを用いて記述します。
    - 2. この記述されたプログラムが、算術回路にコンパイルされ、制約システム（通常はR1CS）として表現されます。
    - 3. この制約システムが、多項式（QAPなど）に変換され、証明者がこの多項式に関する数学的な主張（例：多項式が特定の根を持つこと）を検証者に証明することで、元の計算の正しさを保証します。

（主な構成要素）:
- 入力ワイヤ：証明したい値（公開入力）と、秘密にしたい値（秘密入力）を回路内に取り込む通路。
- 内部ワイヤ：途中計算の結果を次のゲートへ渡す中間線。制約が互いに整合するかをチェックする対象。
- 加算ゲート：二つのワイヤ値を足し合わせて次のワイヤへ送る装置。線形制約を表現する基本部品。
- 乗算ゲート：二つのワイヤ値を掛け合わせ、非線形の関係を作る装置。証明の複雑さは主に乗算数で決まる。
- 定数ワイヤ／定数ゲート：有限体の特定値を注入する部品。モジュラー減算や係数付き演算に使用。
- 出力ワイヤ：最終結果を公開部分へ出す通路。検証者が期待する値と一致することが制約で保証される。
- 制約（例：R1CSのA・B・C行列、PLONKの多項式制約）：各ゲート・ワイヤの関係を方程式で縛る仕組み。回路=制約集合と同義。
- 選択子／カスタムゲート（上級）：よく使う演算をまとめるための係数やルックアップ。回路を小さく高速にする拡張要素。

---

#### R1CS(Rank-1 Constraint System：ランク1制約システム)

1. R1CS とは：
  
- R1CS（Rank-1 Constraint System／ランク1制約システム）は、プログラムの「正しく計算できているか」を有限体上の一次方程式の積で表す方式です（行列・ベクトルの積で記述）。
- たとえば 〈a, w〉 × 〈b, w〉 = 〈c, w〉 のように、ワイヤ値 w の線形結合どうしを掛け合わせて別の線形結合と一致させる形に整えます。これにより「足し算と掛け算だけの算術回路」が厳密な制約集合へ変換され、Groth16 や PLONK など多くの zk-SNARK で扱いやすくなります。

- R1CS は「計算がちゃんとできたかどうか」をチェックするための、足し算と掛け算だけで作った仕組みです。
- ゲームのスコア表みたいに、いくつかのルール（制約）を全部クリアできたら「正解！」になります。
  - 3つの箱（A・B・C）に数字カードを並べる。
  - A箱の数字カードを足してから B箱の数字カードを足し、それぞれの合計を掛け算する。
  - その結果が C箱のカードを足し合わせた数とぴったり同じなら、そのルールはクリア。
  - たくさんあるルール全部でこれが成功すれば「計算はまちがっていません」と言える。

2. 重要な理由：
 
- R1CS（Rank-1 Constraint System）は、ゼロ知識証明（ZKP）の分野、特にzk-SNARKs（Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge）において、**計算を検証可能な数学的表現に変換するため**の極めて重要な基盤技術です
  - 1. ゼロ知識証明システムの主要な算術化戦略である
    - R1CSは、多くのzk-SNARKsのプロトコルで採用されている一般的な算術化（Arithmetization）戦略です。
    - 算術化の役割：算術化とは、デジタル回路や計算モデルの配線やゲート操作を、数学的な表現に符号化するプロセスであり、証明の生成に適した形式に変換する目的で行われます。
    - 計算の表現：R1CSは、複雑な計算（例えばPython関数など）を、効率的に検証可能な線形方程式の制約の集合として表現する方法を提供します。この制約が満たされていることが、計算が正しく実行されたと見なされるための基礎となります。
  
  - 2. zk-SNARKの簡潔性（Succinctness）を実現する鍵となる
    - R1CSは、zk-SNARKの重要な特性である「簡潔性」と「高速検証」を可能にするための中間表現として機能します。
    - QAPへの変換：zk-SNARKのプロセスにおいて、R1CSで表現された計算は、バックエンドフェーズでQuadratic Arithmetic Program (QAP) を形成する多項式方程式のセットに変換されます。
    - 効率的な検証：このR1CSからQAPへの変換は、SNARKの作成において不可欠な要素です。行列演算を多項式方程式に符号化することで、元の回路の実行トレースをより簡潔に表現し、検証者はR1CSのすべての計算を実行することなくQAP検証方程式を効率的にチェックできます。これにより、検証者の実行時間を準線形に短縮し、大幅な高速化が実現します。

  - 3. 広く採用されている証明システムの基礎である
    - R1CSは、ゼロ知識証明の分野で最も広く使用されているいくつかのプロトコルやツール群の基盤となっています。
    - 主要プロトコルの採用：R1CSは、Groth16 や Lurk など、多くのzk-SNARK実装で利用されています。
    - 開発ツールの焦点：ゼロ知識証明のための多くのドメイン固有言語（zkDSL）やライブラリは、R1CSをターゲットとしています。
      - Circom は、算術回路をR1CSにコンパイルするために設計された古典的な言語です。
      - O1JS は、R1CSから導出されたゼロ知識証明の生成と検証に熟練したライブラリです。
      - Arkworks や Gnark などの主要なZKPライブラリは、R1CS制約をサポートし、開発者がR1CSインスタンスを構築するための構成要素（ガジェット）
      を提供しています。

  - このように、R1CSは、計算の正確さを証明するための汎用的な数学的フレームワークを提供し、特にzk-SNARKsの実用性と効率性の根幹を担っているため非常に重要です。

---

#### QAP

1. R1CS を QAP にする目的：

- 多項式表現に落とし込み、ゼロ知識証明（zk-SNARK）を効率的かつ簡潔に検証可能にするため。
- 複雑な計算を「行列の制約」という形（R1CS）から、「多項式の方程式」という形（QAP）に変換することで、検証者（Verifier）の作業を劇的に少なくするため
   
2. 生成プロセスでの役割：
   
- R1CS は「足し算して掛ける」形の制約ですが、そのままだと証明サイズを小さくするのが難しい。
  - R1CSはバラバラの制約集合となっている
  - これを一本のが多項式に変換する
- そこで R1CS 全体を一本の多項式等式にまとめられる QAP（QuadraticArithmetic Program）へ変換します。
- これによって **「多項式コミットメント＋ペアリング」** で一気に検証できるようになり、Groth16 などの zk-SNARK で小さく高速な証明が作れます。

3. 多項式が中心となる理由：
 
- **回路全体が正しく実行されたかどうかという多数の制約**を、たった一つの数学的なチェックに変換・集約できるという性質を持っているから！
- - 評価・補間など計算道具が豊富だから

---

#### Pinocchio (ピノキオ)プロトコル

2013年に発表されたzk-SNARKプロトコルの一つです。

Pinocchioは、この「zk-SNARKs」という概念を、理論だけでなく現実の計算（汎用計算）に適用するための道を切り開いたプロトコルです。

1. 実用化への前進とされる理由：

- 証明したい計算（例：C言語のプログラム）を数学的に検証可能な形式に変換するプロセス、**算術化（Arithmetization(アリスメティゼーション)）**において革新的なアプローチを採用した。
- R1CSとQAPの使用：Pinocchioは、計算を表現するためにR1CS（Rank-1 Constraint System）を採用し、さらにそれをQAP（Quadratic Arithmetic Program）へと変換するアプローチを採用しました
- R1CSとQAPを用いて実用的な非対話型の簡潔な証明方法を示した。
   
2. QAP の用い方：

- 回路→R1CS→QAP→証明生成
- QAP の多項式構造とペアリングを組み合わせ、短い証明を生成・検証している。
-「すべての制約を一本化してコミットし、ペアリング 1〜2 回で検証する橋渡し」として使用している

3. ペアリングの役割：
   
- 検証者は楕円曲線ペアリングを使用してQAP方程式をチェックすることができる。
- ペアリングを利用することにより、**元の計算の複雑さ（回路のサイズ）に関係なく、短時間で検証することが可能となった。**
- 「多項式で表現された複雑な計算の正しさを、迅速かつ秘密を漏らさずに証明するために、検証者が使用する暗号学的定規」のようなもの
- 証明の正当性を効率よく検査するための基盤演算を提供している

---

#### Groth16

1. 人気の理由：

- ZKPプロトコルの中でも特に効率性と簡潔性に優れているため
  - 1. 証明サイズ（Proof Size）が極めて小さい
    - 簡潔な証明：Groth16は、わずか3つの群要素からなる最小の証明サイズを実現しました。
    - オンチェーンコストの削減。ガス代などの削減になる
  - 2. 圧倒的に高速な検証時間
    - 高速な検証：Groth16は、3つのペアリング操作（楕円曲線上の数学的操作）を含む高速な検証を実現します
    -  ブロックチェーンでの利便性：zk-Rollupなどのスケーリングソリューションにおいて、Ethereumのようなベースレイヤーのスマートコントラクト上で検証を行う際、検証時間が速いことは即時の取引確定と低コストに直結するため、理想的とされています
  - 3. 幅広い採用と既存エコシステムとの互換性
    -  代表的な採用事例：Groth16は、匿名通貨ZcashのSaplingアップグレード や、分散型アプリケーションをプライベートに構築するためのプラットフォームAleo など、多くのプロジェクトで採用されています。
    - 開発ツールのサポート：Circom、Noir、Gnark、Arkworks、SnarkJS、ZoKrates などの主要な開発ライブラリやツールキットがGroth16をバックエンドとしてサポートしており、エコシステムが成熟している点も強みです。 
    -  中間表現との親和性：Groth16は、広く使われている算術化スキームであるR1CS（Rank-1 Constraint System）を中間表現として使用します。

2. 長所と短所：

- 長所：効率・簡潔さ(上述の通り)。
- 短所：**回路固有の Trusted Setup が必要(つまり回路ごとにセットアップをやる必要がある)**。
   
3. Pinocchio との違い：

- Pinocchio（2013）は QAP＋KZG を用いた初期の実用 zk-SNARK。
- Groth16（2016）は Pinocchio を洗練し、証明サイズ・検証コスト・セットアップサイズを大幅に圧縮しました。   
- セットアップ要件の性質にも差異。

主な違い

- 証明サイズ: Pinocchio は 3ペアリング命題を支える 8 要素程度（G1×6, G2×2）。Groth16 は G1×2 + G2×1 の計3要素で済み、通信量が約半分以下。
- 検証コスト: Pinocchio はペアリング 3回＋追加乗算が必要。Groth16 はペアリング 2回（最適化でほぼ2回）に減り、検証器が軽量。
- CRS（SRS）構造: Pinocchio は証明・検証で別々の多数の要素を要求。Groth16 は「Powers of Tau」を分離し、大小2段階のセットアップで汎用性を高めつつ総サイズも縮小。
- Prover 計算: Groth16 は QAP 評価をより効率的に分解し、FFT フレンドリーな実装で Pinocchio より高速。メモリ使用量も少ない傾向。
- セキュリティ証明: Groth16 はペアリング方の最小構成に伴い、Knowledge of Exponent Assumption（KEA）下で厳密な安全性証明を提供。Pinocchio も同系統だが、Groth16 のほうが形式化が進んだ。
- 実装・採用: Groth16 は Zcash や多くの zk-SNARK システムのデファクト標準。Pinocchio は研究史的なマイルストーンとして認知されつつ、実用では Groth16 に置き換えられた。

---

#### PLONK

PLONK（Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge）は、2019年 に発表されたzk-SNARKs（ゼロ知識簡潔非対話型知識論証）の一種であり、従来のSNARKsが抱えていた大きな課題を解決し、ゼロ知識証明の応用範囲を劇的に広げた重要なプロトコルです。

1. Groth16 に対する利点：
  
- ユニバーサル・更新可能セットアップを導入したことで回路ごとの再セットアップが不要となった。
- モジュール性も高い。

- Universal/Updatable SRS: 一度の「Powers of Tau」セットアップで多数の回路を再利用可能。回路変更のたびにセレモニーをやり直す Groth16 と比べ、開発サイクルが速く、運用コストが低い。
- 回路定義の柔軟性: PLONKish IOP により、足し算・掛け算だけでなく置換（Permutation）やルックアップ（Lookup）、カスタムゲートを自然に組み込める。複雑な計算でも制約数を圧縮しやすい。
- 拡張性: PLONK を基盤に Turbo/UltraPLONK、Halo2、Plonky2 など多様な改良版が登場。レンジチェックや Poseidon などを効率化する拡張が揃い、モダンな ZK プロジェクトで採用しやすい。
- 開発者エコシステム: Circom/PSE 版 Halo2 など、PLONK系ライブラリが充実。回路 DSL・証明システム・OSS 事例が豊富で、学習・実装コストを抑えられる。
- Trusted Setup の透明性向上: Updatable SRS なので新たな参加者が貢献して古い「毒性廃棄物」への信頼を補強できる。Groth16 の回路専用セットアップより不信時のリカバリが容易。

2. なぜ回路ごとのセットアップが不要か：
  
- 普遍的（Universal）で更新可能な構造化参照文字列（SRS）を導入したから
  - 一度のセットアップで所定サイズ以下の任意回路を扱える「普遍的」な SRS を用いるため。
  - このSRSは所定サイズ以下の全てのプログラムに対して扱える

### Week 5

#### 個別質問

1. nullifier は何をするもので、なぜ重要ですか？

- Nullifierの最も重要な役割は、同じゼロ知識証明が二度使用されることを防ぐこと
- ダブルシグナリング防止（Prevent double signaling）」と呼ばれる機能を実現するために設計された一意の識別子です
- Nullifier（ナリファイア）は「この秘密（例：ある入金メモ）を一度使ったことがあるか」を判定するための識別子です。秘密値と回路内の追加データからハッシュのように生成され、同じ秘密を再利用しようとすると同じ nullifier が出力されます。

2. trapdoor(トラップドア) は何をするもので、なぜ重要ですか？

- Semaphore（セマフォ）アイデンティティを構成する非常に重要な要素の一つです。
- 1. trapdoorの役割（何をするものか）
  - アイデンティティの構成要素: Semaphoreの各アイデンティティは、次の3つの要素で構成されています。
    - 1. trapdoor (秘密の値)
    - 2. nullifier (秘密の値)
    - 3. commitment (公開の値)
  - アイデンティティコミットメントの生成: trapdoorとnullifierという2つの秘密の値のハッシュは、「アイデンティティシークレット」と呼ばれます。このアイデンティティシークレットをさらにハッシュ化したものが、**「アイデンティティコミットメント」**となります。 アイデンティティコミットメントは、プロトコル内で人々を表すために使用される公開値であり、Ethereumアドレスのようなものと考えることができます

- 2. なぜ重要か
  - trapdoorは、匿名性を保ちながらグループ内での行動を証明するために不可欠な秘密鍵のような役割を果たします。
    - 1. 匿名シグナルの認証: trapdoorを含む秘密の値は、Semaphoreのゼロ知識証明を生成し、シグナル（メッセージ、投票、承認など）を認証するために使用されます。 これらの秘密の値は、Ethereumの秘密鍵のようなものとして捉えられます。
    - 2. 証明生成の基盤: ユーザーが匿名でメッセージを送信する際、この秘密の値（trapdoorとnullifier）を用いて自身がグループのメンバーであることの証明（メンバーシップ証明）を作成します。
    - 3. プライバシー保護: 証明を生成するために、ユーザーは自分のプライベートなアイデンティティ情報（秘密の値）を使用する必要があります。そのため、証明の生成は、クライアント側の暗号化のように、ユーザー自身のデバイス上の保護された環境でローカルに行われることが推奨されます。これにより、元のアイデンティティを明かすことなく、検証可能で匿名なメッセージを発信できるというSemaphoreの主要な目的が達成されます

3. Semaphore / UniRep / RLN を比較してください。

Semaphore、UniRep、およびRLNは、いずれもゼロ知識証明（ZK-Proof）技術を活用したプロトコルであり、主に匿名性とプライバシー保護を目的としていますが、それぞれ異なる機能と役割を持っています。

| 特徴 | Semaphore | UniRep (Universal Reputation) | RLN (Rate-Limiting Nullifier) |
|------|-----------|--------------------------------|--------------------------------|
| **目的** | 匿名シグナリング：グループのメンバーであることを証明し、元のアイデンティティを明かすことなくメッセージ（投票、承認など）を発信すること。二重シグナリング（二重投票など）の防止。 | 匿名ユーザーデータ/評判管理：匿名IDを通じてユーザーデータを安全に管理し、ユーザーのプライバシーを保護しながらトラストレスなやり取りを可能にする。ZKアプリケーションの強力なメモリ層として機能する。 | 匿名環境でのスパム防止：匿名性を維持しながら、システムとのやり取りの頻度（レート制限）を制御する。 |
| **主要技術** | ゼロ知識プロトコル (ZK)。バイナリMerkle Tree (匿名性集合)。 | ゼロ知識プロトコル (ZK)。Epoch Keys (短命な識別子) を使用して匿名でデータを変更・証明。 | ZKガジェット/プロトコル。Shamir's Secret Sharing (SSS) スキームを利用。グループメンバーシップ証明にSemaphoreを利用。 |
| **機能/焦点** | グループメンバーシップの証明と匿名メッセージの発信に焦点を当てる。グループはオフチェーン/オンチェーンで管理可能。 | ユーザーのプライベートデータの保存と取得に焦点を当てる。評判（データ）には、好み、活動、所有権など様々な側面を含める。ユーザーがデータの開示や変更を完全にコントロールする。 | レート制限メカニズムを提供する。もしユーザーが設定された制限（例：15秒間に1メッセージなど）を超えてメッセージを送信すると、Shamir's Secret Sharingにより秘密鍵が再構築され、ペナルティ（ステークの没収など）が課される。 |
| **関連性** | Ethereum上のdApps向けのシンプルで汎用的なプライバシー層として設計されている。UniRepはSemaphore上に構築されている。BandadaはオフチェーンのSemaphoreグループ管理を簡素化するインフラストラクチャを提供する。 | Semaphoreの上に構築された評判システムまたはプロトコルである。匿名ID（エポックキー）を使用してユーザーデータ変更を**アテスター（アプリケーション）**が安全に証明する。 | 匿名環境の健全性を維持するためのツールであり、Semaphoreが提供する匿名性セット（グループメンバーシップ証明）を利用する。RLNは、オークションの入札制限や匿名チャットでのDoS攻撃防止などに使用できる。 |

--------------------------------------------------------------------------------

- 1. Semaphore (匿名シグナリングプロトコル)
  - Semaphoreは、ユーザーがグループの証明可能なメンバーであると同時に、元のアイデンティティを明らかにすることなくメッセージを送信できるように設計されています。
    - 匿名性とグループ：Semaphoreアイデンティティは、2つの秘密の値（trapdoorとnullifier）と1つの公開値（identity commitment）で構成されます。これらのアイデンティティコミットメントがMerkle Tree（匿名性集合/グループ）の葉として登録されます。
    - 二重シグナリング防止：Semaphoreは、nullifier hashという値を使用して二重シグナリングを防ぐメカニズムを提供します。これは、アイデンティティの秘密鍵と特定のスコープ（テーマ）のハッシュに基づいて生成され、同じユーザーが同じスコープで二度証明を作成することを防ぎます。
    - 利用シーン：プライベート投票、内部告発（Whistleblower applications）、匿名DAOなど、匿名でグループの一員として行動したい場合に利用されます。

- 2. UniRep (匿名ユーザーデータ/評判管理プロトコル)
  - UniRepは、Semaphoreの上に構築されたプロトコルであり、匿名ユーザーデータと評判の管理を主な機能とします。
    - データと匿名性：UniRepは、ユーザーごとに少量のデータ（現在の実装では200バイト）を匿名で保存することを可能にします。アプリケーションは、ユーザーのアイデンティティを知ることなく、短命な匿名識別子であるエポックキー (epoch keys) を使用してデータを変更できます。
    - ユーザー主権：ユーザーデータはパブリックな場所に保存されますが、暗号化されており、ユーザーの同意なしにデータが明らかにされたり変更されたりすることはありません。これにより、ユーザーはプラットフォームにデータを貸し出すのではなく、データを所有する状態を実現します。
    - 相互運用性：ユーザーデータは公開されているため、どのアプリケーションでもそのデータに基づいて証明を作成し、相互運用性を高めることができます。
    - 利用シーン：匿名レビュー/推薦、ピアツーピアの匿名融資（信用スコアとして評判データを利用）、匿名マーケットプレイス、匿名グループチャット、医療記録の管理など、ユーザーの評判やデータ履歴が重要となるアプリケーションの基盤となります。

- 3. RLN (レート制限ヌリファイア)
  - RLNは、匿名環境におけるスパムやDoS攻撃を防ぐことを目的としたプロトコルまたはZKガジェットです。Semaphoreが提供する匿名シグナリングの能力を土台として、その上にレート制限のレイヤーを追加します。
  - シャミアの秘密分散 (SSS) の利用：RLNの核となるのは、Shamir's Secret Sharing (SSS) スキームです。ユーザーがメッセージを送信する際、ZK証明と共にシークレットシェアが公開されます。
  - レート制限違反の検出：ユーザーが設定されたレート制限（例：特定の時間またはイベント内でのメッセージ送信回数）を超えてメッセージを送信すると、複数のシークレットシェアが公開されます。

4. Semaphore / UniRep / RLN で使われる主要な暗号概念は何ですか？

- これら3つのプロトコルに共通する最も重要な暗号概念は、ゼロ知識証明 (ZKP) 。
- これらのプロトコルでは、開発者が最小限の労力でZKPを生成・検証できるよう、Solidityコントラクト、Circom回路、JavaScriptライブラリが提供されています。
- Semaphore (匿名シグナリング) の主要暗号概念
  - EdDSA (エドワーズ曲線デジタル署名アルゴリズム)
  - Merkle Tree (マークルツリー)
  - Poseidon ハッシュ関数
  - Nullifier (ヌリファイア)
- UniRep (匿名データ/評判管理) の主要暗号概念
  - エポックキー (Epoch Keys)
  - 非対称/対称暗号化
  - Merkle Tree (データのネスト)
  - zk-ECDSA
- RLN (レート制限ヌリファイア) の主要暗号概念
  - Shamir's Secret Sharing Scheme (SSS)
  - シークレットシェアの公開
  - Merkle Tree
  - Circom Circuit

#### 一般質問（各プロジェクトごとに）

##### Semaphore

- 1. 動機と機能：何のために作られ、何を実現しますか？
  - 動機
    - 権力の制限（Limit Power）：  
      - 多くの情報を持つ者（権力者）がその知識を基に力を得ることを防ぎます。
      - 個人のデータやアイデンティティをプライベートに保つことは、権力を分散させることにつながります。
    - 言論の自由の促進（Promote Freedom of Speech）：
      - 発言や執筆によって報復を受けることへの恐怖を取り除くことで、自由な思考を促します。
      - 考えを検閲する第一歩は、その著者を攻撃することであるため、匿名性はこれを防ぎます。
    - 評判の保護（Safeguard Reputation）：
      - 人々のアイデアが「誰が言ったか」ではなく、「何を言ったか」に基づいて評価されることを可能にします。
      - これにより、客観的な視点からアイデアを評価することができます。
    - メッセージの独立性：
      - アイデアをその所有者のアイデンティティから切り離すことを可能にします。
      - メッセンジャー（発信者）のアイデンティティを保護することが、メッセージそのものよりも重要になる場合があります
  - 機能
    - 匿名シグナリング：
      - ユーザーがグループに参加し、元のアイデンティティを明かすことなく、メッセージ、承認、または投票などのシグナルを送信することを可能にします。
    - グループメンバーシップの証明：
      - ユーザーが特定のグループのメンバーであることを検証可能なゼロ知識証明を作成します。
      - このグループは匿名性集合として機能します。
    - 二重シグナリングの防止：
      - 同じ証明が二度作成されること（二重投票など）を防ぐためのメカニズムを提供します。
      - このために、アイデンティティの秘密鍵と特定のスコープ（テーマ）のハッシュであるnullifierを使用します。

- 2. ユースケース：非技術者にも説明できる実用例を挙げてください。
  - プライベートな意思決定（Private Voting）：
    - 特定のDAO（分散型自律組織）のメンバーだけが参加できる匿名投票。
    - 誰が投票したかは分からないが、その人が正当なメンバーであり、二重に投票していないことは証明できます。
  - 内部告発アプリケーション（Whistleblowing Applications）：
    - 会社や組織の従業員が、報復を恐れることなく不正行為や問題を匿名で報告するシステム。
  - 匿名DAO/コミュニティ：
    - 組織のメンバー（特定のNFTやSBTを所有する人々、または企業の従業員など） が、現実の評判と切り離された環境で、安心してアイデアを投稿したりチャットしたりできる場。
  - オンライン実験：
    - ユーザーが匿名で質問に答えたり、メッセージを送信したり、集団でアート作品を制作したりする実験的なアプリケーション。

- 3. ハードル：採用に向けた課題や改善点は？
  - 課題
    - 1. 技術の複雑性：
      - ゼロ知識証明などの暗号技術は、数学や暗号のバックグラウンドがない人々にとって理解が難しく、技術の複雑性が大きな課題となっています。
    - 2. 開発ツールの不足（過去の状況）：
      - シンプルで実用的な開発ツールの利用可能性がまだ限られており、技術的な概念をさらに抽象化するステップが必要です。
    - 3. 人々の無関心：
      - プライバシーや匿名性がなぜ重要なのか、データがどのように使われているのかについての意識と教育が不足していることが、人々の無関心につながっている可能性があります
  - 改善点と今後の方向性
    - 1. グループ管理インフラストラクチャの構築：
      - グループの作成、メンバーの追加、削除、更新などを管理するためのインフラストラクチャ（クラウドまたはセルフホスト型のダッシュボード）を構築するというアイデアがあります。
      - Bandada はこのギャップを埋めるインフラストラクチャであり、オフチェーンのSemaphoreグループの管理を簡素化します。
    - 2. 分散型グループのためのコントラクト：
      - オンチェーンの属性（SBTやNFTの所有、または特定の資産額など）に基づいて、外部の承認なしにユーザーが直接グループに参加できるアテステーションコントラクト（オンチェーンのスマートコントラクト）を作成すること。
    - 3. 開発者体験とドキュメントの改善：
      - 目標が明確で、主要な価値観や概念が容易に伝わるようにすること、また、コードの品質を高めることが、コミュニティの成長と技術の採用に不可欠です。教育的なウェブサイトを作成することを含め、開発者体験とドキュメントの改善を継続しています。
    - 4. コミュニティの強化：
      - グラントプログラムなど、強力なコミュニティを育成するための施策を展開しています。

- 4. 回路の読み取り

https://github.com/semaphore-protocol/semaphore

https://deepwiki.com/semaphore-protocol/semaphore

概要を解説したDeepWiki
https://deepwiki.com/search/semaphoreno_d8a60d5e-bc23-407f-8949-484f746138ca


```circom
pragma circom 2.1.5;

include "babyjub.circom";
include "poseidon.circom";
include "binary-merkle-root.circom";
include "comparators.circom";

// Semaphore回路は3つの主要な部分に分けることができます。
// 第一部では、Semaphoreアイデンティティの生成を行います。
// つまり、公開鍵とそのハッシュ（コミットメントと呼ばれる）の生成で、
// これは公開値として使用されます。
// 第二部では、アイデンティティコミットメントがMerkle木（Semaphoreグループ）の
// 一部であるかどうかを検証します。つまり、メンバーシップ証明の検証を行います。
// 第三部では、nullifierの生成を行います。これは証明のスコープと
// 公開鍵の導出に使用される秘密（秘密スカラー）のハッシュです。nullifierは
// 同じ証明が二度検証されることを防ぐために使用されます。
// 最後に、回路にはメッセージが含まれます。これはユーザーが定義する
// 任意の匿名値、またはその値のハッシュです。
template Semaphore(MAX_DEPTH) {
  // 入力シグナル
  // 入力シグナルは'message'と'scope'を除いて全てプライベートです。
  // secretは、EdDSA秘密鍵から生成されるスカラーです。
  // 秘密鍵の代わりに秘密スカラーを使用することで、この回路では
  // こちらで定義されている公開鍵生成のステップ1、2、3をスキップできます：
  // https://www.rfc-editor.org/rfc/rfc8032#section-5.1.5
  // これにより回路がより効率的でシンプルになります。
  // アイデンティティがどのように生成されるかについて詳しくは、
  // Semaphoreアイデンティティパッケージを参照してください：
  // https://github.com/semaphore-protocol/semaphore/tree/main/packages/identity
  signal input secret;
  signal input merkleProofLength, merkleProofIndex, merkleProofSiblings[MAX_DEPTH];
  signal input message;
  signal input scope;

  // 出力シグナル
  // 出力シグナルは全て公開です。
  signal output merkleRoot, nullifier;

  // 秘密スカラーは素数サブグループ位数'l'内でなければなりません。
  var l = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

  component isLessThan = LessThan(251);
  isLessThan.in <== [secret, l];
  isLessThan.out === 1;

  // アイデンティティ生成
  // 回路では、Baby Jubjub（https://eips.ethereum.org/EIPS/eip-2494）を使用して
  // 秘密からEdDSA公開鍵を導出します。
  // これは基本的に2つの座標を持つ点に過ぎません。
  // その後、公開鍵のハッシュを計算し、これがコミットメント、
  // つまりSemaphoreアイデンティティの公開値として使用されます。
  var Ax, Ay;
  (Ax, Ay) = BabyPbk()(secret);

  var identityCommitment = Poseidon(2)([Ax, Ay]);

  // メンバーシップ証明の検証
  // 出力として渡されるMerkle rootは、Merkle proofの入力を通じて
  // 回路内で計算されたものと等しくなければなりません。
  // 'BinaryMerkleRoot'テンプレートがどのように動作するかについて詳しくは、
  // https://github.com/privacy-scaling-explorations/zk-kit.circom/blob/main/packages/binary-merkle-root/src/binary-merkle-root.circom
  // を参照してください。
  merkleRoot <== BinaryMerkleRoot(MAX_DEPTH)(identityCommitment, merkleProofLength, merkleProofIndex, merkleProofSiblings);

  // nullifier生成
  // nullifierは、特定のスコープと特定のアイデンティティによって生成された
  // 証明を本質的に識別する値です。これにより、外部から同じnullifierを持つ
  // 別の証明が既に生成されているかどうかを誰でもチェックできます。
  // このメカニズムは、例えば二重支払いや二重投票を防ぎたい場合に
  // 特に有用です。
  nullifier <== Poseidon(2)([scope, secret]);

  // messageは実際には回路内で使用されません。
  // messageに適用される二乗は、Circomのコンパイラに制約を追加させ、
  // 攻撃者によってその値が変更されることを防ぐ方法です。
  // 詳細はこちら：https://geometry.xyz/notebook/groth16-malleability
  signal dummySquare <== message * message;
}
```

回路の要点（行順に追跡）

- pragma circom 2.1.5：Circom v2.1.5の構文・標準ライブラリ前提。コンパイル時はcircom@2.1.5で固定推奨。
- include群：BabyPbk（EdDSA公開鍵生成）、Poseidon、BinaryMerkleRoot、LessThan(251)などを外部テンプレートとして利用。
- 入力信号
  - secret: BabyJub上の秘密スカラー。EdDSA秘密鍵のラストステップと同義。
  - merkleProofLength: 実際の証明（ツリーの深さ）がMAX_DEPTHより短い場合に使う。
  - merkleProofIndex: 挿入時の葉インデックス（経路ビット列としてBinaryMerkleRoot内部で利用）。
  - merkleProofSiblings[MAX_DEPTH]: 各レベルのシブリングハッシュ。
  - message/scope: messageは形だけの入力、scopeはnullifier計算に使われる公開値。
- 出力信号
  - merkleRoot: 証明の結果得られたグループルート（公開入力として検証者に渡す）。
  - nullifier: Poseidon(scope, secret)の結果。外部で重複チェックに使用。

主要制約の解説

1. スカラー範囲チェック：LessThan(251)は251ビット未満の数値比較に特化（BabyJubのlが約252ビットなのでギリギリ）。isLessThan.out === 1で強制。
    - 改善提案：LessThanは上限を2^nとして扱うため、定数lを明示的に比較する実装に置き換えるとより厳密（例：Num2Bits(252)＋加算チェック）。
2. 公開鍵生成：BabyPbk()(secret)でBabyJub上の[secret] * BasePointを計算し、Ax, Ayを得る。
    - ここでsecretがl未満であることで曲線上有効点が保証される。
3. コミットメント計算：Poseidon(2)([Ax, Ay])はt=2のPoseidon（意味的にはAx||AyをPoseidonで圧縮）。この値がMerkle木の葉となる。
4. Merkle検証：BinaryMerkleRoot(MAX_DEPTH)は
    - merkleProofLengthを用いて末尾の兄弟ハッシュを飛ばす最適化付き。
    - merkleProofIndex、merkleProofSiblingsから内部でビット展開→左右を選択してPoseidonで親ノードを再帰計算。
    - merkleRoot出力が回路外の公開入力と一致するか検証者がチェックする想定。
5. nullifier生成：
    - Poseidon(2)([scope, secret])。スコープ（例：投票ID）と秘密スカラーが一致しなければ nullifier が一致しないため二重投票検知が可能。
6. メッセージに対するダミー制約：dummySquare <== message * message
    - 実際の回路でmessageが使われないとGroth16で可換性攻撃（malleability）が発生し得るため、少なくとも一度制約にかける。
    - ただしdummySquareを公開する／公開入力に含めるわけではないので、検証者がmessage値を把握したい場合は別途ワイヤを公開とする必要がある。

- 5. チュートリアル

[チュートリアル](https://docs.semaphore.pse.dev/getting-started)

テンプレプロジェクト生成プロジェクト

```bash
npx @semaphore-protocol/cli create my-app --template monorepo-ethers
```

依存関係のインストール

```bash
cd my-app
yarn
```

テンプレアプリの構造

```bash
my-app
├── .yarn
├── apps
│   └── contracts
│   │   └── contracts
|   │   │   └── Feedback.sol
│   │   └── tasks
|   │   │   └── deploy.ts
│   │   └── test
|   │   │   └── Feedback.ts
│   │   └── hardhat.config.ts
│   │   └── package.json
│   │   └── tsconfig.json
│   └── web-app
├── .editorconfig
├── .env
├── .env.example
├── .eslintignore
├── .eslintrc.json
├── .gitignore
├── .prettierignore
├── .prettierrc.json
├── .yarnrc.yml
├── package.json
├── README.md
└── tsconfig.json
```

スマートコントラクトのコンパイル&テスト

```bash
cd apps/contracts
yarn compile
yarn test
```

Sepoliaへのデプロイ

```bash
yarn deploy --semaphore 0x8A1fd199516489B0Fb7153EB5f075cDAC83c693D --network sepolia
```

フロントエンドの起動

```bash
yarn dev
```

##### UniRep

Semaphoreプロトコルの上に構築された、匿名ユーザーデータと評判管理のためのゼロ知識プロトコルです。

- 1. 動機と機能：何のために作られ、何を実現しますか？
  - 動機
    - UniRepの基本的な動機は、ユーザーが自分のデータを完全に制御し、プライバシーを保護しながら、トラストレス（信頼不要）なオンラインでのやり取りを可能にすることです。
    - データ主権の回復：
      - Web2のアプリケーションでは、ユーザーがデータをプラットフォームに「貸し出している」状態にあり、データのハッキングや収益化のリスクがあります。
      - UniRepは、プラットフォームがユーザーのデータを保持しない**非カストディアル（Non-custodial）**なアプリケーションを促進し、データ漏洩のリスクを減らします。
    - 評判の拡張：
      - 従来の評判（レピュテーション）の概念を拡張し、好み、活動、連携、所有権など、ユーザーデータのさまざまな側面を含むように設計されています。
  - 機能
    - UniRepは、ゼロ知識技術を活用して、ZKアプリケーションのための強力なメモリ層として機能します。
    - 1. 匿名識別子によるデータ変更： 
      - UniRepは、時間と共に変化するエポックキー (Epoch Keys)短命な匿名識別子を使用します。
      - アプリケーション（アテスター）は、ユーザーのアイデンティティを知ることなく、このエポックキーを用いてユーザーデータを匿名で安全に変更することができます。
    - 2. 匿名での証明とデータの制御： 
      - ユーザーは、自分の情報に関する事実を証明し、結果を保存することができます。
      - データは公開されている場所に保存されますが、ユーザーの同意なしにデータが明らかにされたり、変更されたりすることはありません。
    - 3. 相互運用性： 
      - ユーザーデータは公開されているため、どのアプリケーションでもそのデータに基づいて証明を作成することができ、トラストレスな相互運用性が実現します。

- 2. ユースケース：非技術者にも説明できる実用例を挙げてください。
  - UniRepは、プライバシーが守られた環境で、ユーザーの過去の行動や属性を匿名で証明する必要がある、あらゆるアプリケーションの基盤となり得ます。
  - 匿名オンラインマーケットプレイス（Amazonのようなもの）： 
    - ユーザーは匿名で商品を購入し、購入履歴をプラットフォームに知られることなく安全に保存できます。
    - この購入履歴に基づいて、ユーザーのプライバシーを侵害することなく、クライアント側でおすすめ商品が計算されます。
  - 匿名信用スコア（P2P融資）： 
    - 従来の融資プロトコルが過剰担保に依存しているのに対し、UniRepではユーザーの評判データ（信用スコア）がレンディングプロトコルの規則遵守に基づいて変化します。
    - ユーザーは、具体的な過去のローン履歴を明かさずに、自分が信用に足る借り手であることを匿名で証明できます。
  - プライバシーを保護したメッセージング： 
    - ユーザーは、自分のEthereumアドレスを制御していることを一度だけ証明し、その証明をユーザーデータに保存することで、メッセージを送るたびに身元を明かすことなく匿名でグループチャットに参加できます。
  - 評判に基づく匿名アクセス： 
    - 匿名でGitHubにコードを公開したい開発者が、コミット数や成功したPR数などの評判指標をデータとして持ち、その評判を証明することで、身元を明かさずに特定のリポジトリへのプッシュアクセスを得ることができます。
  - 匿名ジャーナリズム： 
    - 特定のニュース組織に所属するジャーナリストが、報復を恐れることなく情報を公開する際、自分がその信頼できる組織の一員であることだけを証明し、ニュースの信頼性を高めながら、元のアイデンティティを隠すことができます。
  - 医療記録の相互運用性： 
    - 複数の病院（アテスター）が患者の医療記録を匿名でユーザーデータにアテステーション（証明）します。
    - ユーザーは、必要に応じてそのデータの所有権をzkProofで証明し、どの病院にも個人情報を渡すことなく、必要な情報へのアクセスを許可できます。

- 3. ハードル：採用に向けた課題や改善点は？
  - 1. 技術の複雑性と開発者体験の未熟さ：
    -  ゼロ知識証明技術自体が複雑であり、数学や暗号の背景がない人にとって理解が難しいという課題があります。
    -  UniRepを含むZK技術の開発者体験（Developer Experience, DX）はまだ非常に粗い（rough）状態にあり、実装が複雑で難しいことが、採用の最大の欠点（con）として挙げられています。
  - 2. プロトコルの完全性への依存：
    - プラットフォームがハッキングされるリスクからは保護されますが、ユーザーはプロトコル実装の欠陥や暗号技術自体の失敗に対して潜在的に脆弱になります。このため、ユーザーは偽りの安心感を持つ可能性があるという課題があります。
  - 3. データ変更（書き込み）の制約：
    - UniRepにおいて、ユーザーデータの変更（mutate）を行うには、ブロックチェーンへの**書き込みアクセス（トランザクション送信）**が必要です。
    - データの読み取りや証明（Read/Proof operations）はブロックチェーンの制約から独立してスケーリングできますが、書き込み操作はブロックチェーンの制限（例：1秒あたりのトランザクション数）の影響を受けます。
  - 4. 証明生成時間の課題：
    - 特定の証明（例：Ethereumアドレス所有権を証明するための初期のECDSA証明）の生成に約5分かかることがありましたが、これはユーザーデータに証明を保存する工夫により、後のメッセージ送信時の証明時間を約1秒に短縮する形で対応されています。

- 4. 回路の読み取り

回路は以下に格納

https://github.com/unirep/unirep/packages/circuits/circuits

https://deepwiki.com/unirep/unirep

各サーキットの解説を依頼した時のDeepWikiのやりとり

https://deepwiki.com/search/bigcomparatorscircom_f91fc066-77ad-4141-b4c3-c4012805a5b7

- 5. チュートリアル

[チュートリアル](https://developer.unirep.io/docs/getting-started/create-unirep-app)

テンプレプロジェクト作成

```bash
npx create-unirep-app
```

ビルド

```bash
yarn build
```

ローカルブロックチェーン起動

```bash
yarn contracts hardhat node
```

ローカルブロックチェーンへデプロイ

```bash
yarn contracts deploy
```

以下のようになればOK!

```bash
-----------------------------------------------------------------
Epoch tree depth: 17
State tree depth: 17
History tree depth: 17
Number of epoch keys per epoch: 3
Total fields per user: 6
Sum fields per user: 4
Replacement field nonce bits: 48
Replacement field data bits: 205
-----------------------------------------------------------------
Make sure these match what you expect!
-----------------------------------------------------------------
Deploying EpochKeyVerifier
Deploying ReputationVerifier
Deploying UserStateTransitionVerifier
Deploying SignupVerifier
Deploying EpochKeyLiteVerifier
Deploying ScopeNullifierVerifier
Deploying Unirep
-----------------------------------------------------------------
Bytecode size of Unirep: 17212 bytes
Gas cost of deploying Unirep: 3599963
Deployed to: 0x83cB6AF63eAfEc7998cC601eC3f56d064892b386
-----------------------------------------------------------------
Unirep app with epoch length 300 is deployed to 0x9A676e781A523b5d0C0e43731313A708CB607508
Config written to /Users/harukikondo/git/core-program/sample/unirep-app/packages/relay/.env
✨  Done in 2.35s.
```

Relayerサーバー起動

```bash
yarn relay start
```

フロントエンド起動

```bash
yarn frontend start
```

- ユーザーの登録(グループへの参加)
- ポイントをもらう(Request Data)
- ユーザー状態遷移(User State Transition)
- 自分のポイントを証明する(Prove Data)

##### RLN

RLN（Rate-Limiting Nullifier）のによって開発されたzk-gadget/プロトコルです。

- 1. 動機と機能：何のために作られ、何を実現しますか？
  - 動機
    - RLNが開発された主要な動機は、匿名環境におけるスパムとDoS（サービス拒否）攻撃の防止です
    - スパム/Sybil攻撃への対抗：
      - 匿名性が高いアプリケーション（例：匿名チャット）では、ユーザーの身元がわからないため、誰でも無制限にスパムメッセージを送信したり、Sybil攻撃（一人のユーザーが多数の偽アカウントを作成する行為）を行ったりする可能性があります。
      - これにより、ユーザー体験やアプリケーション全体の機能が著しく低下するリスクがあります。
    - 抑止力：
      - RLNは、匿名性を保ちながら、システムとのやり取りの頻度（レート）を制限し、もしその制限を破った場合には**ペナルティ（罰則）**を課すことで、スパム行為に対する強い抑止力として機能します
  - 機能
    - RLNは、匿名性を維持しつつレート制限を実現するために、ゼロ知識証明と**Shamirの秘密分散法 (Shamir's Secret Sharing Scheme, SSS)**という主要な暗号概念を活用しています。
    - 1. レート制限の制御： 
      - RLNは、ユーザーが特定の時間枠内やイベント内（例：15秒間に1メッセージなど）で行うことができるアクションの数を制限します。
    - 2. 秘密の再構築によるスパム対策： 
      - ユーザーがメッセージ（シグナル）を送信する際、ZK証明と共にシークレットシェアと呼ばれる断片的な情報が公開されます。 
      - もしユーザーがレート制限に違反して規定以上のメッセージを送信した場合、十分な数のシークレットシェアが公開され、Shamirの秘密分散法によって元の秘密鍵（プライベートキー、またはアイデンティティコミットメント）が再構築されてしまいます。 
      - これにより、スパマーの正体を特定し、「キック」（システムからの追放やステークの没収）といったペナルティを課すことが可能になります。
    - 3. 匿名性の維持： 
      - RLNは、匿名性集合の一員であることを証明するためにSemaphoreの機能を活用しています。レート制限を遵守している限り、ユーザーのアイデンティティは匿名に保たれます。

- 2. ユースケース：非技術者にも説明できる実用例を挙げてください。
  - 匿名掲示板・チャットでのスパム対策：
    - Redditのような匿名掲示板や、Discordのような大規模な匿名グループチャットにおいて、「1つの投稿に対して1日にコメントできる回数を1回まで」のように制限します。これにより、誰かが悪意を持って大量のスパムメッセージを投稿してシステムを機能停止させる（DoS攻撃）のを防げます。
    - もし制限を破ってスパム行為を行った場合、その匿名ユーザーの身元が明らかになり、ペナルティ（例：デポジットした担保の没収）が課されます。
  - 匿名オークションの入札制限：
    - オークションシステムにおいて、特定のアイテムに対する入札数をユーザーごとに制限します。
    - これにより、一人のユーザーが多数の匿名アカウントを使ってオークションを不当に操作する行為を防ぐことができます。
  - 分散型・匿名型のDoS攻撃防止：
    - CloudflareのようなDoS攻撃対策システムを、匿名かつ分散型の方法で実現できます。
    - これにより、保護対象のサービスはユーザーの身元を知ることなく、攻撃者からのトラフィックを遮断できます。

- 3. ハードル：採用に向けた課題や改善点は？
  - 1. 技術的な複雑性：
    - RLNはゼロ知識証明（ZK-Proof）技術の一種であり、数学や暗号の知識がない人にとってはその仕組み（特にShamirの秘密分散法とZK証明の組み合わせ）が複雑で、実装や理解が難しいという課題があります。
  - 2. 証明生成時間とUX：
    - RLNのシグナリング部分はCircom回路で実装されており、一般にZK証明の生成には計算負荷がかかり、一定の処理時間を要します。これがユーザー体験（UX）に影響を与える可能性があります。
  - 3. 罰則システムの設計：
    - RLNの主要な機能は、違反者に対して秘密鍵を公開しペナルティを課すことにあります。
    - ペナルティとして担保（ステーク）を没収する場合、ユーザーはシステムを利用するために一定の経済的リスクを負う必要があり、これが新規ユーザーの参加ハードルとなる可能性があります。
  - 4. 開発環境の成熟度：
    - ZK技術の採用を拡大するには、シンプルで使いやすい開発ツールの提供や、技術的な概念をさらに抽象化することが求められます。
    - RLNについても、JavaScriptライブラリが提供されていますが、RustやPythonなどのライブラリも開発中であり、開発環境の成熟が求められます。

- 4. 回路の読み取り

回路は以下に格納されている

https://github.com/Rate-Limiting-Nullifier/circom-rln

https://deepwiki.com/Rate-Limiting-Nullifier/circom-rln

回路の解読を依頼した時にDeepWiki
https://deepwiki.com/search/rln_94f7ef2e-6cab-4858-8956-0cbbf5810424

- 5. チュートリアル

#### TLSNotary

- 1. 動機と機能：何のために作られ、何を実現しますか？
- 動機：なぜTLSだけでは不十分なのか？
  - TLSNotaryが開発された最大の動機は、**「データの出所証明（Data Provenance）」と「プライバシー」**を両立させることです。
  - 1. データの真正性の証明ができない (非否認性の欠如) 通常のTLS（HTTPSの「s」の部分）は、サーバーとユーザー（Prover）間の通信を盗聴や改ざんから守ります。しかし、このデータが「本物である」ということを第三者（Verifier/検証者）に証明する機能はありません。 これは、TLSが対称鍵暗号を使用しており、ユーザー（Prover）がサーバーと同じ秘密鍵を知っているためです。もしユーザーが悪意を持てば、データを改ざんした後で、対応する改ざん後のチェックサム（MAC）を自分で計算できてしまうからです。
  - 2. 既存の共有方法の問題点 ユーザーがウェブサービスから取得したデータを他者に共有しようとする場合、OAuthなどの仕組みもありますが、これはアプリケーションが必要以上の情報にアクセスする権限を委任させてしまうことが多く、プライバシーの侵害や、サーバーによる監視・検閲のリスクがあります。また、そもそも多くのサーバーは他者へのデータアクセスを提供したがらないという問題もあります。
- 機能：何を実現するか？
  TLSNotaryは、**セキュアな多者間計算（MPC）とゼロ知識証明（ZKP）** を活用して、これらの課題を解決します

  | 機能 | 詳細 |
  |------|------|
  | データの真正性保証 | 通常のTLS接続に検証者（Verifier）または公証人（Notary）を参加させる**多者間計算（MPC）**を用いることで、ユーザーが秘密鍵への単独アクセスを持つことを防ぎます。これにより、検証者は外部の信頼に依存せず、データの真正性を暗号学的に保証できます。 |
  | 選択的開示（プライバシー保護） | ユーザー（Prover）は、証明したいデータの中から開示したい部分だけを選択し、それ以外の機密情報（リクエスト内容やデータの一部）は隠したまま、データの正しさを証明できます。この機能は、W3Cの検証可能なクレデンシャル（Verifiable Credentials）標準における「プレゼンテーション」という用語にインスパイアされています。 |
  | ポータビリティの実現 | ユーザーは、ウェブサイトの許可を得ずに（パーミッションレスで）「このサーバーからこのデータを受け取った」という証明（Proof）を作成し、オフチェーンまたはオンチェーンで検証可能にし、データを真にポータブルにします。 |
  | サーバーへの透明性 | TLSNotaryが介在していても、データを送信するウェブサーバー側から見ると、ユーザーとの接続は通常のTLS接続と変わりません。ウェブサービスの改変は必要ありません。 |

- 2. ユースケース：非技術者にも説明できる実用例を挙げてください。
- TLSNotaryは、「自分しか見られない、ウェブ上の重要な情報」について、**「その内容を他者に信じさせつつ、知られたくない情報は秘密にする」** ことを可能にします。
- 実用例

  | カテゴリ | 実用例（シナリオ） | 実現できること |
  |----------|-------------------|----------------|
  | 金融・資産証明 | ローンを組む際に、**「一定以上の資産を保有していること」**を証明したい。 | 銀行口座の詳細な残高を明かすことなく、必要な「閾値」を超えているという事実のみを証明できます。また、オンラインバンキングでの送金取引の事実を、ログイン情報やその他の機密情報を隠したまま証明できます。 |
  | 身元・属性証明 | 特定の地域（例：東京都）の住民限定のサービスを利用したい。 | 具体的な自宅住所を公開することなく、**「東京都民であること」**など特定の条件のみを証明できます。また、オンラインの政府サービスから市民権や年齢を確認することにも使えます。 |
  | 評判・経験の移行 | 新しいライドシェアサービス（Ponber）が、競合（Uber）の優良ドライバーに特典を与えたい。 | Uberのドライバーが自分のマイページにログインし、優良ドライバーであることを示す情報をUberの許可なく証明として作成し、Ponberに提出できます。この際、Uberの機密情報やドライバーの必要以上の個人情報はPonberに渡りません。AirbnbやStravaなどのプラットフォームでの経験や信頼性を確認する用途にも使えます。 |
  | 健康・医療情報 | 保険会社に**「健康状態が良好であること」**を証明したい。 | 個人の医療記録（MyHealthなど）を公開せずに、健康診断結果や特定の病歴がないことなど、必要な情報のみを証明できます。 |
  | オンチェーン連携 | 予測市場で、特定のYouTuberの登録者が10万人を超えるか否かを判定したい。 | 予測市場のようなオンチェーンプロダクトが、従来のオラクルではコストが高く提供できないような、特定のウェブサイト上のオフチェーンデータ（登録者数など）を安価かつ検証可能な形で取得し、判定に利用できます。 |

- 3. ハードル：採用に向けた課題や改善点は？
  - TLSNotary（zkTLS）は大きな可能性を秘めていますが、実用化に向けた課題がいくつか特定されています。これらは、主に技術的な制約、ユーザー体験（UX）の課題、法的な整理の必要性に分けられます。
  
  - 技術的な制約と改善点
    - 課題
      | 課題分類 | 詳細課題 | 改善点・対策 |
      |----------|----------|--------------|
      | **技術的制約** | **Web2サービスの仕様依存** | |
      | | 証明の対象となるWeb2サービスがAPI仕様を変更した場合、zkTLSを利用するサービス側もメンテナンスが必要 | オンチェーンで検証を行う場合、コントラクトのアップグレードやガバナンスを考慮した設計が必要 |
      | | **複数の証明生成の複雑さ** | |
      | | Webページに表示されるデータが複数のAPIエンドポイントから取得される場合、TLSNotaryでは1つのTLS通信に対し1つのProofしか生成できないため、複数のProofを個別に作成する必要があり、実装が複雑 | より効率的な技術的な最適化が求められる。また、より効率的なMPCプロトコルの実装により、総データ転送量の削減が進行中 |
      | | **大きな通信オーバーヘッド** | |
      | | underlyingの多者間計算（MPC）の性質上、検証者と証明者間の通信帯域が、サーバーから受信するデータサイズよりも大幅に大きくなる（例：100KBのレスポンスに対して約39MBのアップロードデータ） | 2025年に予定されているプロトコルのアップグレードで、より効率的なMPCプロトコルが導入され、総データ転送量の減少が期待 |
      | | **対応範囲の限定** | |
      | | 現時点では、Proof生成の対象はWebブラウザを通じてログイン可能なサービスに限定されており、ネイティブアプリや特定のデバイスからのデータには対応不可 | 将来的には対応範囲の拡大が期待される |
      | | **TLSバージョンのサポート** | |
      | | 現在、TLSNotaryはTLS 1.2をサポートしているが、TLS 1.3のサポートは未対応 | TLS 1.3のサポートはロードマップに含まれている |
      | **セキュリティ・プライバシー** | **匿名性と再利用性の問題** | |
      | | 多くのユースケースでは、Proofにユーザー識別要素が含まれていないと、Proofが第三者に使い回されるリスクが発生 | 匿名性（アンチシビル）を保ちつつ、Proofにある程度のユーザー識別要素を含める必要がある |

    - 改善点
      | 課題分類 | 詳細課題 | 改善点・対策 |
      |----------|----------|--------------|
      | **ユーザー体験（UX）** | **導入のハードル** | |
      | | Proofを作成するためには、ブラウザ拡張機能またはスマホネイティブアプリの導入が必要です。ブラウザ拡張機能はPC依存でインストールが必要であり、スマホアプリは再ログインが必要でダウンロードの手間がかかります。 | ユーザーのストレスを軽減するため、App Clip（軽量版アプリ）の採用など、インストールや再ログインの手間を軽減する工夫が他プロトコルで試みられています。 |
      | | **Proof生成時間** | |
      | | ZK Proofの生成は計算負荷が高く、一定の処理時間を要するため、ユーザーに待機時間が発生します。デバイス性能やネットワーク環境にも依存します。 | ユーザーの不安を和らげるために、待機中に分かりやすく工夫されたUI/UXが重要となります。技術的な最適化による計算速度の向上が継続的に求められます。 |

    - 法的な整理の必要性
      - 技術的にはあらゆるウェブデータを証明可能ですが、企業が保有する知的財産（IP）の観点から、法的なグレーゾーンが存在します。
      - zkTLSは、ユーザーがプラットフォーム上で生成したデータ（視聴履歴、フォロー、購入履歴など）といった**「正当にユーザーのものであるデータ」**を守るために活用されるべきです。
      - 企業に正当な所有権があるデータやアルゴリズム（例：Spotifyのトップアーティスト、企業のレコメンデーションアルゴリズムなど）に対して、ユーザーが許可なくzkTLSを使用すべきではないという線引きが必要です。**「ユーザーのデータとして扱うべきか、企業のデータとして扱うべきか」** の曖昧な領域について、法的な整理を進めることが、zkTLSの健全な普及に不可欠です。

### WeeK6

以下のコマンドでまずサーキットをコンパイルする

```bash
chmod +x ./scripts/compile-HelloWorld.sh
./scripts/compile-HelloWorld.sh
```

#### 2.1 Trusted Setup

- 1. `HelloWorld.circom` の回路は何をしますか？

  aとbを掛け合わせて出力するだけのシンプルな回路

  ```circom
  pragma circom 2.0.0;

  /*This circuit template checks that c is the multiplication of a and b.*/  
  template Multiplier2 () {  

    // Declaration of signals.  
    signal input a;  
    signal input b;  
    signal output c;  

    // Constraints.  
    c <== a * b;  
  }

  component main = Multiplier2();
  ```

2. Phase 1（Powers of Tau）とは？
   - 複数の人がランダム性を寄与し共通参照文字列（CRS）の基盤を生成する MPC セレモニー。  
   - 中間値（toxic waste）を適切に破棄することが安全性の鍵。

3. Phase 1 と Phase 2 の違いは？
   - **Phase 1 は汎用** 
   - **Phase 2 は回路固有**。

#### 2.2 非二次制約（Non-Quadratic Constraints）

1. `compile-Multiplier3-groth16.sh`の実装

  ```bash
  chmod +x ./scripts/compile-Multiplier3-groth16.sh
  ./scripts/compile-Multiplier3-groth16.sh
  ```

2. `error[T3001]` の意味
  - Circom の制約は二次までとなっている。
  - 3項積を一度に置くと非二次制約になりエラーとなる。
  - 中間信号で2回に分ける必要がある。

3. 以下のように修正する

  ```circom
  pragma circom 2.0.0;

  // [assignment] Modify the circuit below to perform a multiplication of three signals
  template Multiplier3 () {  

    // Declaration of signals.  
    signal input a;  
    signal input b;
    signal input c;
    signal output d;  

    // 中間信号用の変数
    signal temp;

    // Constraints.  
    temp <== a * b;
    d <== temp * c;
  }

  component main = Multiplier3();
  ``` 

#### 2.3 Groth16 と PLONK

- 1. 今度は Gloth16ではなくPLONKを使ってコンパイルするスクリプトを作る

  - PLONK は Phase 2 の（回路固有）寄与が不要。構築フローや zkey 形式が Groth16 と異なる。
  - コントラクトサイズの違い
    - Gloth16の方は170行くらい
    - PLONKの方は700行くらい

    ```sh
    #!/bin/bash

    # Multiplier3.circomをPLONK証明システム用にコンパイルおよびセットアップするスクリプト

    # ----------------------------------------------------
    # 1. 環境設定
    # ----------------------------------------------------
    cd contracts/circuits

    # 回路ディレクトリの作成
    mkdir -p Multiplier3

    # powersOfTau28_hez_final_14.ptau (普遍的なトラステッドセットアップ)のダウンロード
    if [ -f ./powersOfTau28_hez_final_14.ptau ]; then
        echo "powersOfTau28_hez_final_14.ptau がすでに存在します。スキップします。"
    else
        echo 'Downloading powersOfTau28_hez_final_14.ptau'
        # Hermezのptauファイルを使用
        wget https://hermez.s3-eu-west-1.amazonaws.com/powersOfTau28_hez_final_14.ptau
    fi

    echo "Compiling Multiplier3.circom..."

    # ----------------------------------------------------
    # 2. 回路のコンパイル
    # ----------------------------------------------------
    # R1CS、WASM、SYMファイルを生成
    circom Multiplier3.circom --r1cs --wasm --sym -o Multiplier3

    # R1CSの情報を表示
    snarkjs r1cs info Multiplier3/Multiplier3.r1cs

    # ----------------------------------------------------
    # 3. PLONKのセットアップ（ZKeyの作成）
    # ----------------------------------------------------
    echo "Starting PLONK setup and generating initial zkey..."

    # Groth16の代わりにplonk setupを使用
    # R1CSファイルとptauファイルから最初のZKeyファイルを生成
    snarkjs plonk setup Multiplier3/Multiplier3.r1cs powersOfTau28_hez_final_14.ptau Multiplier3/circuit_0000.zkey

    # ----------------------------------------------------
    # 4. ZKeyの確定
    # ----------------------------------------------------
    echo "Renaming zkey file. Contribution is not required for PLONK."

    # PLONKでは普遍的なSRSが使用されるため、Groth16のような個別の貢献フェーズは不要です。
    # 0000.zkeyをfinal.zkeyにリネームして、以降のコマンドで使用します。
    mv Multiplier3/circuit_0000.zkey Multiplier3/circuit_final.zkey

    # ----------------------------------------------------
    # 5. 検証キーの生成とエクスポート
    # ----------------------------------------------------
    echo "Exporting verification key..."

    snarkjs zkey export verificationkey Multiplier3/circuit_final.zkey Multiplier3/verification_key.json

    # ----------------------------------------------------
    # 6. Solidity PLONK Verifierコントラクトの生成
    # ----------------------------------------------------
    echo "Exporting PLONK Verifier Solidity Contract..."

    # Groth16の代わりにplonkverifierコマンドを使用
    # コントラクト名も 'Multiplier3VerifierPlonk.sol' に変更して区別しやすくします
    snarkjs zkey export solidityverifier Multiplier3/circuit_final.zkey ../Multiplier3VerifierPlonk.sol

    echo "PLONK setup for Multiplier3 is complete."
    cd ../..
    ```

#### 2.4 検証とテスト

まず以下のコマンドでバージョン情報をあげてテストコマンドを実装

```bash
npm run test
```

#### 2.5 回路ライブラリ

## 2024年分の回答

### Week1

## 1. SHA-256の特徴

SHA-256は、一般的に広く使用されているハッシュ関数であり、ゼロ知識証明(ZKP)の文脈では主に**ベンチマーク**または**大規模な算術回路**の例として扱われます。

| 特徴 | 詳細 |
|------|------|
| **回路サイズ** | SHA-256の計算は、ZKP回路内で**比較的大きな回路**になります。例えば、R1CS形式のベンチマークでは、59,281の制約で構成される大規模な回路として評価されています |
| **算術化のボトルネック** | SHA-256のようなハッシュ関数は、算術回路(R1CSなど)に変換する際に、乗算ゲートが**約27,000ゲート**必要となるため、システム全体のボトルネックとなることが実験から示されています |
| **ベンチマークでの利用** | ZKPシステムのパフォーマンス評価において、SHA-256は行列乗算やMerkleツリー計算と並び、**一般的に使用されるベンチマーク**として採用されています |
| **用途** | プルーバーが秘密の512ビットの原像 $x$ を知っていること(公開された256ビットのハッシュ値 $y$ にハッシュ化される)を検証する、2対1のハッシュ関数の証明に用いられます |

## 2. Poseidonの特徴と利点

Poseidonは、**ゼロ知識証明(ZKP)システムでの効率的な使用を目的として特別に設計された新しいハッシュ関数**です。

### Poseidonの主な特徴

- **ZKPシステム向けの設計**:   
  Poseidonは、ZKPシステム向けに設計された「新しいハッシュ関数」です
- **暗号プリミティブとしての分類**:   
  ZKPフレームワークやライブラリにおいて、PoseidonはSHA256、MIMC、Pedersen、blake2などと並び、「**サーキット・ガジェット(Circuit Gadgets)**」のカテゴリに分類される暗号コンポーネントの一つです
- **軽量な暗号プリミティブ**:   
  ZKP実装では、費用対効果が高く効率的なZKPを確保するために、安価な(inexpensive)暗号プリミティブを使用することが優先されます。Poseidonは、ZKP回路の算術制約(例: R1CS)内で効率的に機能するように設計されたプリミティブであると考えられます

### ZKPにおけるPoseidonの利点と応用事例

PoseidonがZKPにおいて有用な主な利点は、ZKP回路内での**効率的な処理**と、それによる**実用的なアプリケーションへの適用**です。

#### 1. アイデンティティコミットメントへの応用

- GalxeプロトコルやSemaphoreプロトコルでは、ユーザーの**プライベートな秘密ID**と**プライベートな内部ナリファイア**のPoseidonハッシュを計算することで、アイデンティティコミットメントを構築します
- これにより、証明書所有者は仮名性を維持しながら、ZKPを使用して自分のIDの必要な情報を選択的に証明できます
- Galxeプロトコルの現在の検証スタック(BabyZK、Groth16証明、BN254曲線を使用)では、**Poseidonコミットメント**が使用されています

#### 2. 高性能ハードウェアによる処理の最適化

- Irreducibleなどの企業は、ZKPフレンドリーなMerkleツリーを実装するために、NTT(数論変換)とPoseidonハッシュを使用した**完全パイプライン化されたFPGAアーキテクチャ**を特徴としています。これは、大規模な暗号計算をスケーラブルに行うためのハードウェア最適化に適していることを示唆しています

#### 3. プロトコルの柔軟性と量子耐性への対応

- デジタル証明書に関連するプロトコルにおいて、Pedersenバインディング値をPoseidonハッシュに置き換えることが提案されており、Poseidonがzk-STARKツールに適していることが示されています
- また、Poseidonハッシャーは、バイナリ体を使用する新しい技術であるBiniusと比較して、従来のPoseidonハッシャーは効率性で劣るという言及があるものの、これはPoseidonが「従来の」ZKP専用ハッシュ関数としてすでに確立されていることを示しており、ZKP環境において広く利用されている証拠でもあります

## PoseidonがZKPに特化している理由

PoseidonがZKPで有用な理由は、その効率的な設計にあります。

| 特徴 | 詳細 |
|------|------|
| **ZKP専用設計** | ZKPシステム向けに特別に設計された新しいハッシュ関数 |
| **効率的な回路処理** | ZKP回路（R1CSなどの算術制約）内で効率的に機能するように設計されたサーキット・ガジェット |
| **コスト効率** | 従来のハッシュ関数（例：SHA-256）と比較して、ZKPのパフォーマンスと実装を最適化する安価な暗号プリミティブ |

## ハッシュ関数の説明

### ハッシュ関数の定義

ハッシュ関数は、暗号学的プロトコルの基本的な構成要素（ツール）の一つであり、特定の情報を公開せずにその情報の真実性を証明するゼロ知識証明（ZKP）などの暗号技術において利用されます。

### ハッシュ関数の主用途

1. **デジタル署名/認証**
    - 普遍的一方向ハッシュ関数から強力なワンタイム署名スキームを容易に構築
    - 非対話型ZKP（NIZK）では、暗号学的ハッシュ関数を用いて検証者のランダムなチャレンジを置き換え（Fiat-Shamirヒューリスティック）

2. **コミットメントとデータ構造**
    - zk-STARKsの基盤技術として使用し、量子コンピューティングの脅威に対する耐性を提供(XMSS署名もハッシュ関数の一方向性を利用)
    - Merkleツリーの構築に利用。セキュリティはハッシュ関数の衝突耐性特性に基づく

3. **ゼロ知識証明（ZKP）の構成**
    - 証明者と検証者間の信頼構築のため、暗号学的ハッシュ関数がランダムなチャレンジを生成
    - ZKP専用設計のハッシュ関数（例：Poseidon、MIMC）は算術回路内での効率的な演算（安価な暗号プリミティブ）を可能に

## SHA-256の高レベル動作

SHA-256は、ZKPの文脈では主にベンチマークとして評価されており、512ビットの秘密の原像 $x$ を256ビットの公開されたハッシュ値 $y$ にハッシュ化する2対1のハッシュ関数の証明に用いられます。

### ZKP回路におけるSHA-256の表現

| 特徴 | 詳細 |
|------|------|
| **大規模な回路** | ZKP回路内で比較的大きな回路になる |
| **制約数** | R1CS形式では59,281の制約で構成される大規模な回路 |
| **乗算ゲート** | 約27,000の乗算ゲートが必要でシステム全体のボトルネックになる可能性 |
| **バイナリ値の親和性** | 回路のほとんどの値がバイナリのため、zk-SNARKsの証明者にとって有利 |

### 性能と最適化

- **最適化の必要性**:   
  SHA-256ハッシュの計算は通常、システムのボトルネックとなる
- **代数的ハッシュ関数との比較**:   
  SWIFFTなどの代数的ハッシュ関数は約3,000の乗算ゲートで実装可能で、ZKPシステムのパフォーマンスを大幅に向上

## メルクル木が大規模データ検証を効率化する理由

| 効率化の要因 | 詳細 |
|-------------|------|
| **ログスケール（対数的）の効率性** | データセット全体ではなく、検証したいインデックスのデータをログスケールの証明サイズと検証時間で処理 |
| **大規模データのコンパクトな表現** | ハッシュ関数の衝突耐性に基づき、ZKPでオンチェーンに保存された増分的なメルクル木内のユーザーアイデンティティ（Pedersenコミットメント）をメルクルパスで証明 |
| **効率的な検証** | 大規模なデータ全体を検証する代わりに、データが木の中に存在することを示すログサイズの証明のみを検証 |

## Pedersenコミットメントでトランザクションのプライバシーを保つ方法

Pedersenコミットメントは、**秘密情報を隠蔽し、ZKPと組み合わせて秘密情報を公開せずに検証を可能にします**。

### 主要な機能

1. **値の秘匿（Hiding）**
    - 金額や識別情報を隠蔽（封蝋が押された封筒のような働き）
    - Semaphoreフレームワークでは、ユーザーのアイデンティティを隠すために使用

2. **準同型性（Homomorphic property）**
    - コミットメントの準同型な加算(秘匿したまま加算することが可能)を可能にする

3. **ZKPによる検証**  
    秘密情報を明かすことなく以下を証明：
    - コミットされたアイデンティティが有効であること（メルクル木の葉として存在）
    - 証明者がそのPedersenコミットメントの裏にある秘密を知っていること
    - （取引の場合）新しいコミットメントが元のコミットメントとバランスが取れ、金額が一定の範囲内（非負など）であること

### 結果

検証者は情報が正しいこと（取引のバランスが合うこと）を知ることができますが、コミットされた詳細情報（実際の取引金額やユーザーの秘密ID）は一切得られません。

## 署名付き文書の真正性検証方法

署名付き文書やメッセージの真正性検証は、主に**暗号学的ハッシュ関数と公開鍵暗号の原理**を利用して行われます。

### 検証プロセス

1. **非対話型検証の仕組み**
  - 検証者は証明者から受け取った証明（署名）と公開情報を使って数学的な等式が成り立つかをチェック

2. **具体的なチェック**
  - 非対話型ゼロ知識証明（NIZK）において、証明者が秘密の情報 $x$ を知っていることを証明
  - 証明はペア $(t, r)$ として提出され、暗号学的ハッシュ関数 $H$ を使って計算されたチャレンジ $c = H(g, y, t)$ を用いて $t \equiv g^r y^c$ の成立をチェック

3. **その他の検証要素**
  - **否認不可性**:   
    タイム匿名リング署名（TARS）などの署名スキームは、匿名性を保護しながら偽造不可能性を常に保証
  - **権限の検証**:     
    ZKP回路内で署名検証（例：EdDSA署名検証）を行い、特定のシグナルやアクションが適切に承認されていることを証明
  - **ZKPの初期用途**:   
    ZKPは、もともとデジタル署名やユーザー認証の分野で活用

### SNARKs と STARKs

#### 証明システムとは

証明システムは、主に**検証可能な計算（Verifiable Computing, VC）**と呼ばれる暗号プロトコル群を指します。

これは、**信頼できない第三者（証明者 P：Prover）**が、ある計算を正しく実行したこと、またはある事実が真実であることを、検証者（Verifier/V）効率的に保証するための仕組みです。

- 1. 証明システムの基本的な役割.   
  証明システム（Proofs and Arguments）の核心的な役割は、**「計算の正しさの保証」**を提供することにあります。
  - 登場人物
    - 証明者 (P)：計算を実行し、「結果は $y$ です」と主張する側です。このPは信頼されていない可能性があります。
    - 検証者 (V)：Pの主張が本当に正しいかどうかを確認する側です。
  - 目的
    - Vは、Pからの証明（Proof）を検証することで、Pが要求された計算を正確に実行したという保証を得ます。
    - Vは、Pの主張が誤っている場合に騙されないように、Pを尋問します。
    - 例えば、ある企業（V）がクラウドコンピューティングプロバイダー（P）にデータ処理を委託した場合、VはPがプログラムをデータに対して正しく実行したという形式的な保証を得るために証明システムを利用できます。

- 2. 対話とプロトコルの性質
  - 証明システムは、伝統的な数学的な証明とは異なり、主に対話的または確率的な性質を持ちます。
  - 対話型証明（Interactive Proofs: IPs）
    - 1980年代に導入された対話型証明（IPs）は、「証明」の概念を大きく拡張しました。
    - 1. 主張の提示：PとVは共通の入力 $x$ を持ち、Pは計算結果 $y$ を主張します。
    - 2. 対話と検証：VはPに対して一連のチャレンジ（質問）を送り、Pはそれに対して一連の応答（メッセージ）を返します。Vは、この一連のやり取り（トランスクリプト）に基づいて、Pの主張を受け入れるか拒否するかを決定します。
    - 3. 確率的な性質：証明システムは、検証プロセスが無作為な選択を行う確率的な性質を持っています。そのため、検証プロセスが誤った主張を真実であると判定する可能性が、ごくわずかですが存在します。
  - 重要な特性：完全性と健全性
    - 証明システムには、プロトコルとして満たすべき二つの主要な特性があります。
    - **完全性 (Completeness)**：
      - Pが正直であり、計算が実際に正しく実行された場合、Vは必ず（または高い確率で）その証明を有効として受け入れます。
    - **健全性 (Soundness)**：
      - Pが不正を働いて誤った結果を主張した場合、VはPがどれほど計算資源を費やしてVを騙そうとしても、高い確率でその主張を無効として拒否します。

- 3. 証明システムの分類
  - 証明システムは、その「健全性」の要件や「対話性」の有無によって分類されます。
  - (1) 対話型証明（IPs）と引数システム（Arguments）
    - 対話型証明 (IPs)：健全性が非常に強く、たとえPが無限の計算能力を持っていたとしても、誤った主張でVを納得させることが難しい（統計的健全性）とされます。
    - 引数システム (Argument Systems)：健全性の要件がIPsよりも弱く、Pが多項式時間でしか実行できないという前提（計算的健全性）で成立します。不正な証明を見つけるために莫大な計算能力が必要となる「証明」の存在を許容します。
  - (2) ZK-SNARKsとZK-STARKs
    - 現代の暗号技術、特にブロックチェーンやプライバシー保護計算の分野では、**ゼロ知識証明（Zero-Knowledge Proof, ZK）**の性質を持つ証明システムが注目されています。
    - ZK-SNARKs (Succinct Non-interactive ARgument of Knowledge):
      - 簡潔性 (Succinct)：証明のサイズが非常に短く、検証時間も非常に高速です。
      - 非対話性 (Non-interactive)：証明が単一の静的な文字列（Proof）であり、PとVの間の対話が不要です。非対話的なシステムを得るために、対話プロトコルにFiat-Shamir変換が適用されることがよくあります。
      - Polygon zkEVMは、ゼロ知識技術を使用して有効性証明を生成するために、zkProverというコンポーネントを使用しており、その中にはSNARK-proof builderが含まれます。
    - ZK-STARKs (Scalable Transparent ARgument of Knowledge):
      - ZK-SNARKsの新しい親戚であり、**「透明性（Transparent）」**が特徴です。
      - **トラステッド・セットアップ（信頼された設定）**への依存を解消しています。
      - ハッシュと情報理論に純粋に依存しており、楕円曲線やペアリングなどの複雑な暗号学的仮定を避けているため、量子コンピュータを持つ攻撃者に対しても安全であるとされています。zkProverにはSTARK-proof builderが含まれます。

#### input / witness / circuit / proof の定義

##### 1. 🧩 Circuit（回路）

**Circuit（回路）**は、検証したい計算や主張そのものを数学的に表現したものです。  
※ 多項式で表したもの

##### 💡 初心者向けの解説

通常のコンピュータプログラム（例: Java, Python）はゼロ知識証明システムで直接検証できません。

そのため、プログラムを**算術回路 (Arithmetic Circuit)**と呼ばれる形式に変換する必要があります。

###### 🔧 詳細

* **役割:** 検証対象の計算の「仕様書」
* **構造:**
  - 足し算（Addition）や掛け算（Multiplication）などの基本的なゲートのみで構成される
  - 有向非巡回グラフ（DAG: Directed Acyclic Graph）
* **フロントエンド:**
  - 高レベル言語を算術回路にコンパイルする工程やツールを指す。
    - 例: **Circom** — ゼロ知識証明用の算術回路を作成するための言語
* **ゴール:**
  証明者は、回路 $C$ に入力 $x$ と証人 $w$ を与えると期待される出力 $y$ が得られる
  （つまり $C(x, w) = y$ となる）ことを証明する。

---

#### 2. 📥 Input（入力） $x$

**Input（入力）**は、証明者（Prover）と検証者（Verifier）の**双方が知っている公開情報**です。

##### 💡 初心者向けの解説

計算の前提条件や、計算の結果として公開されている値を指します。

##### 🔧 詳細

* **性質:** 公開されています（Public Input）
* **例:**

  * 特定のクラウド計算プロバイダーに実行してほしいプログラムの仕様 $f$
  * ハッシュ関数 $h$ と、その出力である公開ハッシュ値 $y$
    （この $y$ を生成した秘密の元 $w$ が存在するかを証明する場合）
  * Polygon zkEVM のようなロールアップでは、トランザクションや検証に必要なパラメータが Input に相当

---

####3. 🔐 Witness（証人） $w$

**Witness（証人）**は、計算の正しさを証明するために必要な**秘密情報**です。
検証者には公開されません。

これは **「非決定的な入力 (non-deterministic input)」** や **「補助入力 (auxiliary input)」** とも呼ばれます。

##### 💡 初心者向けの解説

Witness は「**秘密の鍵**」や「**主張の裏付けとなる証拠**」のようなものです。
証明者（P）は、この $w$ を知っていることを証明しますが、
$w$ の内容そのものは検証者（V）に明かしません。

### 🔧 詳細

* **性質:** 秘密情報（検証者は $w$ を知らない）
* **役割:** 回路 $C$ が主張 $y$ を満たすためには、$C(x, w)=y$ となる $w$ が存在する必要がある
* **例:**

  * ハッシュ値 $y = h(w)$ が公開されているとき、$w$ は実際のパスワード
  * プログラム実行を証明する場合、$w$ はその**実行トレース（ログ）**となる

---

#### 4. 📜 Proof（証明） $\pi$

**Proof（証明）**は、「回路 $C$ に $x$ と $w$ を入力すると $y$ になる」という主張が正しく行われたことを示す**短いデータ**です。

##### 💡 初心者向けの解説

証明者（P）は $w$ を使って計算を実行し、その計算が正しかったことを示す「領収書」または「署名」として Proof を生成します。

##### 🔧 詳細

* **目的:** 検証者（V）は Proof ($\pi$) を用いて、主張の正しさを高速かつ効率的に確認できる
* **形式:** ZK-SNARKs などでは、Proof は通常 P から V へ送られる**短い静的な文字列**
* **プロセス:**
  - 検証者は $x$（Input）と $\pi$（Proof）を受け取り、
  - 計算の詳細や秘密の $w$ を知らずに主張の正しさを判断できる。
  - 特に ZK-SNARKs では、Proof の**簡潔さ (Succinctness)** が重要とされる。

---

#### 🧭 各要素のまとめ

| 要素              | 役割                      | 情報の性質  |
| :-------------- | :---------------------- | :----- |
| **Circuit (C)** | 検証したい計算（プログラム）の数学的表現    | 共通の仕様書 |
| **Input (x)**   | 公開された前提条件（既知の情報）        | 公開情報   |
| **Witness (w)** | 主張を真実にする秘密の情報（鍵や実行トレース） | 秘密情報   |
| **Proof (π)**   | 主張が真実であることの簡潔で検証可能な保証   | 検証用データ |

 
#### 3. プログラムから証明への変換プロセス

##### 🧮 プログラムから証明への変換プロセス（算術化 / Arithmetization）

このプロセスは **算術化（Arithmetization）** と呼ばれ、コンピューターが行う離散的な操作を、**代数的な制約（多項式の等式）** に変換することを目的としています。

######  🎯 全体のゴール

**検証可能な計算（Verifiable Computation, VC）** の目標は次の通りです。

> 信頼できない証明者 $P$ が、あるプログラム $f$ に秘密の入力 $w$（Witness）と公開入力 $x$（Input）を与えた結果 $y$ が正しい、
> すなわち **$f(x, w) = y$** であることを検証者 $V$ に証明する。

この検証を実現するために、プログラム $f$ は **回路（Circuit）** や **制約（Constraints）** の形に変換されます。

---

###### 🧩 ステップ 1: プログラムの分解と回路（Circuit）への変換

まず、人間が書いた高レベルのプログラムを、証明システムが扱える最小単位の計算ステップに分解します。

###### ① 計算の線形化（Circuit / R1CSへの変換）

通常のプログラムはループ・条件分岐・配列操作などを含みます。
これらをすべて **算術回路 (Arithmetic Circuit)** や **R1CS (Rank-1 Constraint System)** に変換します。

* 算術回路は、足し算（$\text{ADD}$）や掛け算（$\text{MULT}$）などの**基本的な演算ゲート**で構成されるグラフ構造。
* ZK-SNARKs や STARKs では、この回路 $C$ が「検証対象の計算仕様書」となります。
* 例: **Circom** は、ゼロ知識証明用の算術回路を設計するための**ハードウェア記述言語（HDL）**です。

###### ② ブール関数から算術関数への変換（Arithmetization）

ブール論理（$\text{AND}$, $\text{OR}$, $\text{NOT}$）で定義された式を、**有限体 $F$ 上の多項式** に置き換えます。

| ブール関数              | 算術表現（有限体上）          |
| :----------------- | :------------------ |
| $\text{AND}(y, z)$ | $y \cdot z$         |
| $\text{OR}(y, z)$  | $y + z - y \cdot z$ |
| $\text{NOT}(y)$    | $1 - y$             |

これにより、プログラムの実行は「**入力変数と中間変数が特定の多項式制約を満たすこと**」と同義になります。

> この変換を行う工程・ツール群を **フロントエンド（Front End）** と呼びます。
> フロントエンドは、複雑なプログラムを算術回路に効率的に変換する役割を担います。

---

##### 🔍 ステップ 2: トレース（Trace / Witness）の生成

プログラム $f$ に実際の入力 $x$ と $w$ を与えて実行すると、
各ステップで多くの中間変数が生成されます。

* **トレース（Trace）:**
  計算の全過程（各ゲートでの値の割り当て）を記録したもの。
  → 実行ログ・計算履歴とも呼ばれる。
* **Witness:**
  このトレース全体、または秘密の入力 $w$ と中間変数の集合。
  証明者のみが知る「 **証人データ** 」となります。

---

##### 📈 ステップ 3: 多項式（Polynomial）によるエンコーディング

証明者（Prover）は、巨大な**計算トレース（Witness）**を数学的に扱いやすい形で表現するために、多項式を用います。

###### ① 多項式拡張（Polynomial Extension）

* 離散的な値の集合（トレース）を、**低次多項式の評価値（Evaluation）** として再解釈します。
* トレースを補間（interpolate）して得られる多項式を **$P(X)$** とします。
* このとき、膨大な計算情報をたった一つ（または少数）の多項式に**圧縮**できます。

###### ② 代数的な主張への変換（Constraint Satisfaction）

> 「プログラム $f$ の実行は正しかった」
> ⇔ 「多項式 $P(X)$ が、制約多項式 $Q(X)$ によって割り切れる」

具体例（フィボナッチ数列）：

$$
P(x+2) - P(x+1) - P(x) = 0
$$

このような**多項式制約**を満たすことが、計算の正しさを保証します。

さらに、検証者 $V$ は、巨大なトレースを全てチェックする代わりに、**ランダムな点 $r$ で多項式の等式が成り立つか**を確認するだけで済みます。
これにより、検証コストが劇的に削減されます。

---

##### 🪶 ステップ 4: 証明（Proof）の生成と簡潔性の達成

多項式の等式（代数的主張）が真であることを示すために、証明者 $P$ は **証明（Proof, $\pi$）** を生成します。

###### 💡 Proof生成

* 多項式のランダム点での評価値や、**Polynomial Commitment Scheme (PCS)** と呼ばれる暗号技術を利用して、多項式情報を簡潔にコミット（コミットメント）します。

### 💬 非対話性（Non-interactive）の達成

多くの証明システムでは、検証者からのランダムチャレンジを **Fiat–Shamir変換** によってハッシュ関数でシミュレートします。

> これにより、もともと **対話型（interactive）** だったプロトコルを
> **非対話型（non-interactive）** な証明（例: ZK-SNARKs）に変換できます。

---

## ✅ 結果

- 検証者 $V$ は、もはや元のプログラムや巨大な Witness を知る必要がありません。
- 証明者 $P$ から送られる短い Proof $\pi$ を検証するだけで、
- 計算の正しさを信頼性高く確認できます。

---

## 🧭 ステップ概要まとめ

| ステップ           | 内容                        | 主な目的         |
| :------------- | :------------------------ | :----------- |
| 1️⃣ プログラム → 回路 | 高レベルプログラムを算術回路（R1CSなど）に変換 | 計算を数学的に定義    |
| 2️⃣ トレース生成     | 入力と中間値を記録して Witness を形成   | 実行過程の証拠を保持   |
| 3️⃣ 多項式化       | トレースを多項式 $P(X)$ として表現     | 検証を代数的に単純化   |
| 4️⃣ Proof生成    | 多項式制約の成立を暗号的に証明           | 計算の正当性を簡潔に保証 |

 
### Hack and Experiment（作って学ぶ）

#### ZK 電卓
  
#### ZK Battleship（戦艦ゲーム）

#### とてもシンプルなロールアップ

#### ZK パズルを解く

### PLONKについてのブログ記事を執筆する

### フロンティア技術の探究

2023年度の内容でも取り扱ったが改めて概要や機能などを調べてまとめてみる

#### MPC

#### FHE

#### TLSNotary

#### ZKEmail

## 2025年分の回答


## Deepwiki
- [ethereum/zket-core-program](https://deepwiki.com/ethereum/zket-core-program)
- [概要について解説を依頼した時のもの](https://deepwiki.com/search/_d4d98a83-02af-432b-8810-9933e7979378)
